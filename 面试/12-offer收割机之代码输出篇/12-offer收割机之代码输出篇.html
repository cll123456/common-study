<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>建议有时间或者校招要做笔试的同学看下 社招基本只需要看看事件循环的题目 | common-study Doc</title>
    <meta name="description" content="A VitePress site">
    <link rel="stylesheet" href="/common-study/assets/style.ad0100e9.css">
    <link rel="modulepreload" href="/common-study/assets/app.279bf150.js">
    <link rel="modulepreload" href="/common-study/assets/面试_12-offer收割机之代码输出篇_12-offer收割机之代码输出篇.md.c1445f4e.lean.js">
    
    <meta name="keywords" content="common-study 一起学习 面试 面试经历 面经 vue3源码分析">
  <meta name="description" content="此文档主要用于common-study 一起学习面试面试经历面经 vue3源码分析">
  <script>(()=>{const e=localStorage.getItem("vitepress-theme-appearance"),a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-66204374><!--[--><!--]--><!--[--><span tabindex="-1" data-v-40d8faed></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-40d8faed> Skip to content </a><!--]--><!----><header class="VPNav" data-v-66204374 data-v-574cb7e9><div class="VPNavBar has-sidebar" data-v-574cb7e9 data-v-23964494><div class="container" data-v-23964494><div class="VPNavBarTitle has-sidebar" data-v-23964494 data-v-6d41cef0><a class="title" href="/common-study/" data-v-6d41cef0><!----><!--[-->common-study Doc<!--]--></a></div><div class="content" data-v-23964494><!----><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-23964494 data-v-36eceb0c><span id="main-nav-aria-label" class="visually-hidden" data-v-36eceb0c>Main Navigation</span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/common-study/vue3-analysis/" data-v-36eceb0c data-v-bf51d0ee data-v-0c96c854><!--[-->vue3源码分析<!--]--><!----></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-23964494 data-v-513bb74a><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-label="toggle dark mode" data-v-513bb74a data-v-57172cb8 data-v-eeb71742><span class="check" data-v-eeb71742><span class="icon" data-v-eeb71742><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-57172cb8><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-57172cb8><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-23964494 data-v-48b47c0c data-v-06a41780><!--[--><a class="VPSocialLink" href="https://github.com/cll123456/common-study" title="github" target="_blank" rel="noopener noreferrer" data-v-06a41780 data-v-398c9053><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-398c9053><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"></path></svg><span class="visually-hidden" data-v-398c9053>github</span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-23964494 data-v-bcfe4bc6 data-v-3a84883f><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-3a84883f><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-3a84883f><circle cx="12" cy="12" r="2"></circle><circle cx="19" cy="12" r="2"></circle><circle cx="5" cy="12" r="2"></circle></svg></button><div class="menu" data-v-3a84883f><div class="VPMenu" data-v-3a84883f data-v-010f1d8c><!----><!--[--><!--[--><!----><div class="group" data-v-bcfe4bc6><div class="item appearance" data-v-bcfe4bc6><p class="label" data-v-bcfe4bc6>Appearance</p><div class="appearance-action" data-v-bcfe4bc6><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-label="toggle dark mode" data-v-bcfe4bc6 data-v-57172cb8 data-v-eeb71742><span class="check" data-v-eeb71742><span class="icon" data-v-eeb71742><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-57172cb8><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-57172cb8><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div></div></div><div class="group" data-v-bcfe4bc6><div class="item social-links" data-v-bcfe4bc6><div class="VPSocialLinks social-links-list" data-v-bcfe4bc6 data-v-06a41780><!--[--><a class="VPSocialLink" href="https://github.com/cll123456/common-study" title="github" target="_blank" rel="noopener noreferrer" data-v-06a41780 data-v-398c9053><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-398c9053><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"></path></svg><span class="visually-hidden" data-v-398c9053>github</span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-23964494 data-v-702843d0><span class="container" data-v-702843d0><span class="top" data-v-702843d0></span><span class="middle" data-v-702843d0></span><span class="bottom" data-v-702843d0></span></span></button></div></div></div><!----></header><div class="VPLocalNav" data-v-66204374 data-v-a9a4d510><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-a9a4d510><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="menu-icon" data-v-a9a4d510><path d="M17,11H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,11,17,11z"></path><path d="M21,7H3C2.4,7,2,6.6,2,6s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,7,21,7z"></path><path d="M21,15H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,15,21,15z"></path><path d="M17,19H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,19,17,19z"></path></svg><span class="menu-text" data-v-a9a4d510>Menu</span></button><a class="top-link" href="#" data-v-a9a4d510> Return to top </a></div><aside class="VPSidebar" data-v-66204374 data-v-575b3a38><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-575b3a38><span class="visually-hidden" id="sidebar-aria-label" data-v-575b3a38> Sidebar Navigation </span><!--[--><div class="group" data-v-575b3a38><section class="VPSidebarGroup collapsible" data-v-575b3a38 data-v-4c0613ca><div class="title" role="button" data-v-4c0613ca><h2 class="title-text" data-v-4c0613ca>vue3源码分析</h2><div class="action" data-v-4c0613ca><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 24 24" class="icon minus" data-v-4c0613ca><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2zM20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h8c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg><svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon plus" data-v-4c0613ca><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2z M20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11h-3V8c0-0.6-0.4-1-1-1s-1,0.4-1,1v3H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h3v3c0,0.6,0.4,1,1,1s1-0.4,1-1v-3h3c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg></div></div><div class="items" data-v-4c0613ca><!--[--><a class="VPLink link" href="/common-study/vue3-analysis/index.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>介绍</span><!--]--><!----></a><a class="VPLink link" href="/common-study/vue3-analysis/1-learn-reactive/1-learn-reactive.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>1-learn-reactive</span><!--]--><!----></a><a class="VPLink link" href="/common-study/vue3-analysis/2-comp-init/2-comp-init.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>2-comp-init</span><!--]--><!----></a><a class="VPLink link" href="/common-study/vue3-analysis/3-comp-update/3-comp-update.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>3-comp-update</span><!--]--><!----></a><a class="VPLink link" href="/common-study/vue3-analysis/4-init-project/4-init-project.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>4-init-project</span><!--]--><!----></a><a class="VPLink link" href="/common-study/vue3-analysis/5-init-effect/5-init-effect.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>5-init-effect</span><!--]--><!----></a><a class="VPLink link" href="/common-study/vue3-analysis/6-finish-readonly-isReactive/6-finish-readonly-isReactive.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>6-finish-readonly-isReactive</span><!--]--><!----></a><a class="VPLink link" href="/common-study/vue3-analysis/7-finish-ref-computed/7-finish-ref-computed.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>7-finish-ref-computed</span><!--]--><!----></a><a class="VPLink link" href="/common-study/vue3-analysis/8-finish-build/8-finish-build.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>8-finish-build</span><!--]--><!----></a><a class="VPLink link" href="/common-study/vue3-analysis/9-init-comp-mount/9-init-comp-mount.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>9-init-comp-mount</span><!--]--><!----></a><a class="VPLink link" href="/common-study/vue3-analysis/10-finish-comp-props/10-finish-comp-props.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>10-finish-comp-props</span><!--]--><!----></a><a class="VPLink link" href="/common-study/vue3-analysis/11-finish-comp-slots/11-finish-comp-slots.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>11-finish-comp-slots</span><!--]--><!----></a><a class="VPLink link" href="/common-study/vue3-analysis/12-finish-provide-inject/12-finish-provide-inject.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>12-finish-provide-inject</span><!--]--><!----></a><a class="VPLink link" href="/common-study/vue3-analysis/13-finish-custom-render/13-finish-custom-render.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>13-finish-custom-render</span><!--]--><!----></a><a class="VPLink link" href="/common-study/vue3-analysis/14-finish-elem-update/14-finish-elem-update.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>14-finish-elem-update</span><!--]--><!----></a><a class="VPLink link" href="/common-study/vue3-analysis/15-finish-diff/15-finish-diff.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>15-finish-diff</span><!--]--><!----></a><a class="VPLink link" href="/common-study/vue3-analysis/16-finish-comp-update/16-finish-comp-update.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>16-finish-comp-update</span><!--]--><!----></a><a class="VPLink link" href="/common-study/vue3-analysis/17-finish-nextTick/17-finish-nextTick.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>17-finish-nextTick</span><!--]--><!----></a><a class="VPLink link" href="/common-study/vue3-analysis/18-finish-complier-basic/18-finish-complier-basic.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>18-finish-complier-basic</span><!--]--><!----></a><a class="VPLink link" href="/common-study/vue3-analysis/19-complier-basic-codegen/19-complier-basic-codegen.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>19-complier-basic-codegen</span><!--]--><!----></a><!--]--></div></section></div><div class="group" data-v-575b3a38><section class="VPSidebarGroup collapsible" data-v-575b3a38 data-v-4c0613ca><div class="title" role="button" data-v-4c0613ca><h2 class="title-text" data-v-4c0613ca>源码阅读</h2><div class="action" data-v-4c0613ca><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 24 24" class="icon minus" data-v-4c0613ca><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2zM20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h8c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg><svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon plus" data-v-4c0613ca><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2z M20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11h-3V8c0-0.6-0.4-1-1-1s-1,0.4-1,1v3H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h3v3c0,0.6,0.4,1,1,1s1-0.4,1-1v-3h3c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg></div></div><div class="items" data-v-4c0613ca><!--[--><a class="VPLink link" href="/common-study/packages-study/cac/cac.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>cac</span><!--]--><!----></a><!--]--></div></section></div><div class="group" data-v-575b3a38><section class="VPSidebarGroup collapsible" data-v-575b3a38 data-v-4c0613ca><div class="title" role="button" data-v-4c0613ca><h2 class="title-text" data-v-4c0613ca>面试</h2><div class="action" data-v-4c0613ca><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 24 24" class="icon minus" data-v-4c0613ca><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2zM20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h8c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg><svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon plus" data-v-4c0613ca><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2z M20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11h-3V8c0-0.6-0.4-1-1-1s-1,0.4-1,1v3H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h3v3c0,0.6,0.4,1,1,1s1-0.4,1-1v-3h3c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg></div></div><div class="items" data-v-4c0613ca><!--[--><a class="VPLink link" href="/common-study/%E9%9D%A2%E8%AF%95/1-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/1-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>1-前端面试准备</span><!--]--><!----></a><a class="VPLink link" href="/common-study/%E9%9D%A2%E8%AF%95/2-%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E8%BD%AF%E6%8A%80%E8%83%BD/2-%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E8%BD%AF%E6%8A%80%E8%83%BD.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>2-程序员面试软技能</span><!--]--><!----></a><a class="VPLink link" href="/common-study/%E9%9D%A2%E8%AF%95/3-offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8BHTML%E7%AF%87/3-offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8BHTML%E7%AF%87.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>3-offer收割机之HTML篇</span><!--]--><!----></a><a class="VPLink link" href="/common-study/%E9%9D%A2%E8%AF%95/4-offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8BCSS%E7%AF%87/4-offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8BCSS%E7%AF%87.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>4-offer收割机之CSS篇</span><!--]--><!----></a><a class="VPLink link" href="/common-study/%E9%9D%A2%E8%AF%95/5-offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8BJavaScript%E7%AF%87/5-offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8BJavaScript%E7%AF%87.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>5-offer收割机之JavaScript篇</span><!--]--><!----></a><a class="VPLink link" href="/common-study/%E9%9D%A2%E8%AF%95/6-offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AF%87/6-offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AF%87.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>6-offer收割机之性能优化篇</span><!--]--><!----></a><a class="VPLink link" href="/common-study/%E9%9D%A2%E8%AF%95/7-offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8BReact%E7%AF%87/7-offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8BReact%E7%AF%87.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>7-offer收割机之React篇</span><!--]--><!----></a><a class="VPLink link" href="/common-study/%E9%9D%A2%E8%AF%95/8-offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%AF%87/8-offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%AF%87.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>8-offer收割机之前端工程化篇</span><!--]--><!----></a><a class="VPLink link" href="/common-study/%E9%9D%A2%E8%AF%95/9-offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87/9-offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>9-offer收割机之计算机网络篇</span><!--]--><!----></a><a class="VPLink link" href="/common-study/%E9%9D%A2%E8%AF%95/10-offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86%E7%AF%87/10-offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86%E7%AF%87.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>10-offer收割机之浏览器原理篇</span><!--]--><!----></a><a class="VPLink link" href="/common-study/%E9%9D%A2%E8%AF%95/11-offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%AF%87/11-offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%AF%87.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>11-offer收割机之手写代码篇</span><!--]--><!----></a><a class="VPLink link active" href="/common-study/%E9%9D%A2%E8%AF%95/12-offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%AF%87/12-offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%AF%87.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>12-offer收割机之代码输出篇</span><!--]--><!----></a><a class="VPLink link" href="/common-study/%E9%9D%A2%E8%AF%95/13-LeetCode%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83%E9%A2%98%E7%9B%AE/13-LeetCode%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83%E9%A2%98%E7%9B%AE.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>13-LeetCode面试常考题目</span><!--]--><!----></a><a class="VPLink link" href="/common-study/%E9%9D%A2%E8%AF%95/14-offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8BVue%E7%AF%87/14-offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8BVue%E7%AF%87.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>14-offer收割机之Vue篇</span><!--]--><!----></a><a class="VPLink link" href="/common-study/%E9%9D%A2%E8%AF%95/15-vue%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/15-vue%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html" data-v-4c0613ca data-v-4ac05124 data-v-0c96c854><!--[--><span class="link-text" data-v-4ac05124>15-vue项目的性能优化</span><!--]--><!----></a><!--]--></div></section></div><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-66204374 data-v-0e4d175a><div class="VPDoc has-sidebar" data-v-0e4d175a data-v-542b5b3a><div class="container" data-v-542b5b3a><div class="aside" data-v-542b5b3a><div class="aside-curtain" data-v-542b5b3a></div><div class="aside-container" data-v-542b5b3a><div class="aside-content" data-v-542b5b3a><div class="VPDocAside" data-v-542b5b3a data-v-719cedd0><!--[--><!--]--><!--[--><!--]--><div class="VPDocAsideOutline has-outline" data-v-719cedd0 data-v-090513d1><div class="content" data-v-090513d1><div class="outline-marker" data-v-090513d1></div><div class="outline-title" data-v-090513d1>On this page</div><nav aria-labelledby="doc-outline-aria-label" data-v-090513d1><span class="visually-hidden" id="doc-outline-aria-label" data-v-090513d1> Table of Contents for current page </span><ul class="root" data-v-090513d1><!--[--><li style="" data-v-090513d1><a class="outline-link" href="#建议有时间或者校招要做笔试的同学看下-社招基本只需要看看事件循环的题目" data-v-090513d1>建议有时间或者校招要做笔试的同学看下 社招基本只需要看看事件循环的题目</a><!----></li><li style="" data-v-090513d1><a class="outline-link" href="#一、异步-事件循环" data-v-090513d1>一、异步&amp;事件循环</a><!----></li><li style="" data-v-090513d1><a class="outline-link" href="#二、this" data-v-090513d1>二、this</a><!----></li><li style="" data-v-090513d1><a class="outline-link" href="#三、作用域-变量提升-闭包" data-v-090513d1>三、作用域&amp;变量提升&amp;闭包</a><!----></li><li style="" data-v-090513d1><a class="outline-link" href="#四、原型-继承" data-v-090513d1>四、原型&amp;继承</a><!----></li><!--]--></ul></nav></div></div><!--[--><!--]--><div class="spacer" data-v-719cedd0></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-542b5b3a><div class="content-container" data-v-542b5b3a><!--[--><!--]--><main class="main" data-v-542b5b3a><div style="position:relative;" class="vp-doc _common-study_%E9%9D%A2%E8%AF%95_12-offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%AF%87_12-offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%AF%87" data-v-542b5b3a><div><meta name="referrer" content="no-referrer"><h2 id="建议有时间或者校招要做笔试的同学看下-社招基本只需要看看事件循环的题目" tabindex="-1">建议有时间或者校招要做笔试的同学看下 社招基本只需要看看事件循环的题目 <a class="header-anchor" href="#建议有时间或者校招要做笔试的同学看下-社招基本只需要看看事件循环的题目" aria-hidden="true">#</a></h2><h3 id="前言：" tabindex="-1">前言： <a class="header-anchor" href="#前言：" aria-hidden="true">#</a></h3><p><strong>代码输出结果</strong>也是面试中常考的题目，一段代码中可能涉及到很多的知识点，这就考察到了应聘者的基础能力。在前端面试中，常考的代码输出问题主要涉及到以下知识点：<strong>异步编程、事件循环、this指向、作用域、变量提升、闭包、原型、继承</strong>等，这些知识点往往不是单独出现的，而是在同一段代码中包含多个知识点。所以，笔者将这些问题大致分为四类进行讨论。这里不会系统的阐述基础知识，而是通过面试例题的形式，来讲述每个题目的知识点以及代码的执行过程。如果会了这些例题，在前端面试中多数代码输出问题就可以轻而易举的解决了。</p><p>**注：**本文中所有例题收集自牛客网面经、网络博文等，如果侵权，请联系删除！</p><h2 id="一、异步-事件循环" tabindex="-1">一、异步&amp;事件循环 <a class="header-anchor" href="#一、异步-事件循环" aria-hidden="true">#</a></h2><h3 id="_1-代码输出结果" tabindex="-1">1. 代码输出结果 <a class="header-anchor" href="#_1-代码输出结果" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">const promise = new Promise((resolve, reject) =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">  console.log(1);</span></span>
<span class="line"><span style="color:#393a34;">  console.log(2);</span></span>
<span class="line"><span style="color:#393a34;">});</span></span>
<span class="line"><span style="color:#393a34;">promise.then(() =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">  console.log(3);</span></span>
<span class="line"><span style="color:#393a34;">});</span></span>
<span class="line"><span style="color:#393a34;">console.log(4);</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>输出结果如下：</p><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">1 </span></span>
<span class="line"><span style="color:#393a34;">2 </span></span>
<span class="line"><span style="color:#393a34;">4</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>promise.then 是微任务，它会在所有的宏任务执行完之后才会执行，同时需要promise内部的状态发生变化，因为这里内部没有发生变化，一直处于pending状态，所以不输出3。</p><h3 id="_2-代码输出结果" tabindex="-1">2. 代码输出结果 <a class="header-anchor" href="#_2-代码输出结果" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">const promise1 = new Promise((resolve, reject) =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">  console.log(&#39;promise1&#39;)</span></span>
<span class="line"><span style="color:#393a34;">  resolve(&#39;resolve1&#39;)</span></span>
<span class="line"><span style="color:#393a34;">})</span></span>
<span class="line"><span style="color:#393a34;">const promise2 = promise1.then(res =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">  console.log(res)</span></span>
<span class="line"><span style="color:#393a34;">})</span></span>
<span class="line"><span style="color:#393a34;">console.log(&#39;1&#39;, promise1);</span></span>
<span class="line"><span style="color:#393a34;">console.log(&#39;2&#39;, promise2);</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>输出结果如下：</p><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">promise1</span></span>
<span class="line"><span style="color:#393a34;">1 Promise{&lt;resolved&gt;: resolve1}</span></span>
<span class="line"><span style="color:#393a34;">2 Promise{&lt;pending&gt;}</span></span>
<span class="line"><span style="color:#393a34;">resolve1</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>需要注意的是，直接打印promise1，会打印出它的状态值和参数。</p><p>代码执行过程如下：</p><ol><li>script是一个宏任务，按照顺序执行这些代码；</li><li>首先进入Promise，执行该构造函数中的代码，打印<code>promise1</code>；</li><li>碰到<code>resolve</code>函数, 将<code>promise1</code>的状态改变为<code>resolved</code>, 并将结果保存下来；</li><li>碰到<code>promise1.then</code>这个微任务，将它放入微任务队列；</li><li><code>promise2</code>是一个新的状态为<code>pending</code>的<code>Promise</code>；</li><li>执行同步代码1， 同时打印出<code>promise1</code>的状态是<code>resolved</code>；</li><li>执行同步代码2，同时打印出<code>promise2</code>的状态是<code>pending</code>；</li><li>宏任务执行完毕，查找微任务队列，发现<code>promise1.then</code>这个微任务且状态为<code>resolved</code>，执行它。</li></ol><h3 id="_3-代码输出结果" tabindex="-1">3. 代码输出结果 <a class="header-anchor" href="#_3-代码输出结果" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">const promise = new Promise((resolve, reject) =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">  console.log(1);</span></span>
<span class="line"><span style="color:#393a34;">  setTimeout(() =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">    console.log(&quot;timerStart&quot;);</span></span>
<span class="line"><span style="color:#393a34;">    resolve(&quot;success&quot;);</span></span>
<span class="line"><span style="color:#393a34;">    console.log(&quot;timerEnd&quot;);</span></span>
<span class="line"><span style="color:#393a34;">  }, 0);</span></span>
<span class="line"><span style="color:#393a34;">  console.log(2);</span></span>
<span class="line"><span style="color:#393a34;">});</span></span>
<span class="line"><span style="color:#393a34;">promise.then((res) =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">  console.log(res);</span></span>
<span class="line"><span style="color:#393a34;">});</span></span>
<span class="line"><span style="color:#393a34;">console.log(4);</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>输出结果如下：</p><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">1</span></span>
<span class="line"><span style="color:#393a34;">2</span></span>
<span class="line"><span style="color:#393a34;">4</span></span>
<span class="line"><span style="color:#393a34;">timerStart</span></span>
<span class="line"><span style="color:#393a34;">timerEnd</span></span>
<span class="line"><span style="color:#393a34;">success</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>代码执行过程如下：</p><ul><li>首先遇到Promise构造函数，会先执行里面的内容，打印<code>1</code>；</li><li>遇到定时器<code>steTimeout</code>，它是一个宏任务，放入宏任务队列；</li><li>继续向下执行，打印出2；</li><li>由于<code>Promise</code>的状态此时还是<code>pending</code>，所以<code>promise.then</code>先不执行；</li><li>继续执行下面的同步任务，打印出4；</li><li>此时微任务队列没有任务，继续执行下一轮宏任务，执行<code>steTimeout</code>；</li><li>首先执行<code>timerStart</code>，然后遇到了<code>resolve</code>，将<code>promise</code>的状态改为<code>resolved</code>且保存结果并将之前的<code>promise.then</code>推入微任务队列，再执行<code>timerEnd</code>；</li><li>执行完这个宏任务，就去执行微任务<code>promise.then</code>，打印出<code>resolve</code>的结果。</li></ul><h3 id="_4-代码输出结果" tabindex="-1">4. 代码输出结果 <a class="header-anchor" href="#_4-代码输出结果" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">Promise.resolve().then(() =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">  console.log(&#39;promise1&#39;);</span></span>
<span class="line"><span style="color:#393a34;">  const timer2 = setTimeout(() =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">    console.log(&#39;timer2&#39;)</span></span>
<span class="line"><span style="color:#393a34;">  }, 0)</span></span>
<span class="line"><span style="color:#393a34;">});</span></span>
<span class="line"><span style="color:#393a34;">const timer1 = setTimeout(() =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">  console.log(&#39;timer1&#39;)</span></span>
<span class="line"><span style="color:#393a34;">  Promise.resolve().then(() =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">    console.log(&#39;promise2&#39;)</span></span>
<span class="line"><span style="color:#393a34;">  })</span></span>
<span class="line"><span style="color:#393a34;">}, 0)</span></span>
<span class="line"><span style="color:#393a34;">console.log(&#39;start&#39;);</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>输出结果如下：</p><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">start</span></span>
<span class="line"><span style="color:#393a34;">promise1</span></span>
<span class="line"><span style="color:#393a34;">timer1</span></span>
<span class="line"><span style="color:#393a34;">promise2</span></span>
<span class="line"><span style="color:#393a34;">timer2</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>代码执行过程如下：</p><ol><li>首先，<code>Promise.resolve().then</code>是一个微任务，加入微任务队列</li><li>执行timer1，它是一个宏任务，加入宏任务队列</li><li>继续执行下面的同步代码，打印出<code>start</code></li><li>这样第一轮宏任务就执行完了，开始执行微任务<code>Promise.resolve().then</code>，打印出<code>promise1</code></li><li>遇到<code>timer2</code>，它是一个宏任务，将其加入宏任务队列，此时宏任务队列有两个任务，分别是<code>timer1</code>、<code>timer2</code>；</li><li>这样第一轮微任务就执行完了，开始执行第二轮宏任务，首先执行定时器<code>timer1</code>，打印<code>timer1</code>；</li><li>遇到<code>Promise.resolve().then</code>，它是一个微任务，加入微任务队列</li><li>开始执行微任务队列中的任务，打印<code>promise2</code>；</li><li>最后执行宏任务<code>timer2</code>定时器，打印出<code>timer2</code>；</li></ol><h3 id="_5-代码输出结果" tabindex="-1">5. 代码输出结果 <a class="header-anchor" href="#_5-代码输出结果" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">const promise = new Promise((resolve, reject) =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">    resolve(&#39;success1&#39;);</span></span>
<span class="line"><span style="color:#393a34;">    reject(&#39;error&#39;);</span></span>
<span class="line"><span style="color:#393a34;">    resolve(&#39;success2&#39;);</span></span>
<span class="line"><span style="color:#393a34;">});</span></span>
<span class="line"><span style="color:#393a34;">promise.then((res) =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">    console.log(&#39;then:&#39;, res);</span></span>
<span class="line"><span style="color:#393a34;">}).catch((err) =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">    console.log(&#39;catch:&#39;, err);</span></span>
<span class="line"><span style="color:#393a34;">})</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>输出结果如下：</p><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">then：success1</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这个题目考察的就是<strong>Promise的状态在发生变化之后，就不会再发生变化</strong>。开始状态由<code>pending</code>变为<code>resolve</code>，说明已经变为已完成状态，下面的两个状态的就不会再执行，同时下面的catch也不会捕获到错误。</p><h3 id="_6-代码输出结果" tabindex="-1">6. 代码输出结果 <a class="header-anchor" href="#_6-代码输出结果" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">Promise.resolve(1)</span></span>
<span class="line"><span style="color:#393a34;">  .then(2)</span></span>
<span class="line"><span style="color:#393a34;">  .then(Promise.resolve(3))</span></span>
<span class="line"><span style="color:#393a34;">  .then(console.log)</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>输出结果如下：</p><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">1</span></span>
<span class="line"><span style="color:#393a34;">Promise {&lt;fulfilled&gt;: undefined}</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Promise.resolve方法的参数如果是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为resolved，Promise.resolve方法的参数，会同时传给回调函数。</p><p>then方法接受的参数是函数，而如果传递的并非是一个函数，它实际上会将其解释为then(null)，这就会导致前一个Promise的结果会传递下面。</p><h3 id="_7-代码输出结果" tabindex="-1">7. 代码输出结果 <a class="header-anchor" href="#_7-代码输出结果" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">const promise1 = new Promise((resolve, reject) =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">  setTimeout(() =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">    resolve(&#39;success&#39;)</span></span>
<span class="line"><span style="color:#393a34;">  }, 1000)</span></span>
<span class="line"><span style="color:#393a34;">})</span></span>
<span class="line"><span style="color:#393a34;">const promise2 = promise1.then(() =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">  throw new Error(&#39;error!!!&#39;)</span></span>
<span class="line"><span style="color:#393a34;">})</span></span>
<span class="line"><span style="color:#393a34;">console.log(&#39;promise1&#39;, promise1)</span></span>
<span class="line"><span style="color:#393a34;">console.log(&#39;promise2&#39;, promise2)</span></span>
<span class="line"><span style="color:#393a34;">setTimeout(() =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">  console.log(&#39;promise1&#39;, promise1)</span></span>
<span class="line"><span style="color:#393a34;">  console.log(&#39;promise2&#39;, promise2)</span></span>
<span class="line"><span style="color:#393a34;">}, 2000)</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>输出结果如下：</p><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">promise1 Promise {&lt;pending&gt;}</span></span>
<span class="line"><span style="color:#393a34;">promise2 Promise {&lt;pending&gt;}</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">Uncaught (in promise) Error: error!!!</span></span>
<span class="line"><span style="color:#393a34;">promise1 Promise {&lt;fulfilled&gt;: &quot;success&quot;}</span></span>
<span class="line"><span style="color:#393a34;">promise2 Promise {&lt;rejected&gt;: Error: error!!}</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="_8-代码输出结果" tabindex="-1">8. 代码输出结果 <a class="header-anchor" href="#_8-代码输出结果" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">Promise.resolve(1)</span></span>
<span class="line"><span style="color:#393a34;">  .then(res =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">    console.log(res);</span></span>
<span class="line"><span style="color:#393a34;">    return 2;</span></span>
<span class="line"><span style="color:#393a34;">  })</span></span>
<span class="line"><span style="color:#393a34;">  .catch(err =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">    return 3;</span></span>
<span class="line"><span style="color:#393a34;">  })</span></span>
<span class="line"><span style="color:#393a34;">  .then(res =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">    console.log(res);</span></span>
<span class="line"><span style="color:#393a34;">  });</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>输出结果如下：</p><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">1   </span></span>
<span class="line"><span style="color:#393a34;">2</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Promise是可以链式调用的，由于每次调用 <code>.then</code> 或者 <code>.catch</code> 都会返回一个新的 promise，从而实现了链式调用, 它并不像一般任务的链式调用一样return this。</p><p>上面的输出结果之所以依次打印出1和2，是因为<code>resolve(1)</code>之后走的是第一个then方法，并没有进catch里，所以第二个then中的res得到的实际上是第一个then的返回值。并且return 2会被包装成<code>resolve(2)</code>，被最后的then打印输出2。</p><h3 id="_9-代码输出结果" tabindex="-1">9. 代码输出结果 <a class="header-anchor" href="#_9-代码输出结果" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">Promise.resolve().then(() =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">  return new Error(&#39;error!!!&#39;)</span></span>
<span class="line"><span style="color:#393a34;">}).then(res =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">  console.log(&quot;then: &quot;, res)</span></span>
<span class="line"><span style="color:#393a34;">}).catch(err =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">  console.log(&quot;catch: &quot;, err)</span></span>
<span class="line"><span style="color:#393a34;">})</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>输出结果如下：</p><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">&quot;then: &quot; &quot;Error: error!!!&quot;</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>返回任意一个非 promise 的值都会被包裹成 promise 对象，因此这里的<code>return new Error(&#39;error!!!&#39;)</code>也被包裹成了<code>return Promise.resolve(new Error(&#39;error!!!&#39;))</code>，因此它会被then捕获而不是catch。</p><h3 id="_10-代码输出结果" tabindex="-1">10. 代码输出结果 <a class="header-anchor" href="#_10-代码输出结果" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">const promise = Promise.resolve().then(() =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">  return promise;</span></span>
<span class="line"><span style="color:#393a34;">})</span></span>
<span class="line"><span style="color:#393a34;">promise.catch(console.err)</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>输出结果如下：</p><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">Uncaught (in promise) TypeError: Chaining cycle detected for promise #&lt;Promise&gt;</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这里其实是一个坑，<code>.then</code> 或 <code>.catch</code> 返回的值不能是 promise 本身，否则会造成死循环。</p><h3 id="_11-代码输出结果" tabindex="-1">11. 代码输出结果 <a class="header-anchor" href="#_11-代码输出结果" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">Promise.resolve(1)</span></span>
<span class="line"><span style="color:#393a34;">  .then(2)</span></span>
<span class="line"><span style="color:#393a34;">  .then(Promise.resolve(3))</span></span>
<span class="line"><span style="color:#393a34;">  .then(console.log)</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>输出结果如下：</p><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">1</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>看到这个题目，好多的then，实际上只需要记住一个原则：<code>.then</code> 或<code>.catch</code> 的参数期望是函数，传入非函数则会发生<strong>值透传</strong>。</p><p>第一个then和第二个then中传入的都不是函数，一个是数字，一个是对象，因此发生了透传，将<code>resolve(1)</code> 的值直接传到最后一个then里，直接打印出1。</p><h3 id="_12-代码输出结果" tabindex="-1">12. 代码输出结果 <a class="header-anchor" href="#_12-代码输出结果" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">Promise.reject(&#39;err!!!&#39;)</span></span>
<span class="line"><span style="color:#393a34;">  .then((res) =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">    console.log(&#39;success&#39;, res)</span></span>
<span class="line"><span style="color:#393a34;">  }, (err) =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">    console.log(&#39;error&#39;, err)</span></span>
<span class="line"><span style="color:#393a34;">  }).catch(err =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">    console.log(&#39;catch&#39;, err)</span></span>
<span class="line"><span style="color:#393a34;">  })</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>输出结果如下：</p><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">error err!!!</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>我们知道，<code>.then</code>函数中的两个参数：</p><ul><li>第一个参数是用来处理Promise成功的函数</li><li>第二个则是处理失败的函数</li></ul><p>也就是说<code>Promise.resolve(&#39;1&#39;)</code>的值会进入成功的函数，<code>Promise.reject(&#39;2&#39;)</code>的值会进入失败的函数。</p><p>在这道题中，错误直接被<code>then</code>的第二个参数捕获了，所以就不会被<code>catch</code>捕获了，输出结果为：<code>error err!!!&#39;</code></p><p>但是，如果是像下面这样：</p><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">Promise.resolve()</span></span>
<span class="line"><span style="color:#393a34;">  .then(function success (res) {</span></span>
<span class="line"><span style="color:#393a34;">    throw new Error(&#39;error!!!&#39;)</span></span>
<span class="line"><span style="color:#393a34;">  }, function fail1 (err) {</span></span>
<span class="line"><span style="color:#393a34;">    console.log(&#39;fail1&#39;, err)</span></span>
<span class="line"><span style="color:#393a34;">  }).catch(function fail2 (err) {</span></span>
<span class="line"><span style="color:#393a34;">    console.log(&#39;fail2&#39;, err)</span></span>
<span class="line"><span style="color:#393a34;">  })</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>在<code>then</code>的第一参数中抛出了错误，那么他就不会被第二个参数不活了，而是被后面的<code>catch</code>捕获到。</p><h3 id="_13-代码输出结果" tabindex="-1">13. 代码输出结果 <a class="header-anchor" href="#_13-代码输出结果" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">Promise.resolve(&#39;1&#39;)</span></span>
<span class="line"><span style="color:#393a34;">  .then(res =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">    console.log(res)</span></span>
<span class="line"><span style="color:#393a34;">  })</span></span>
<span class="line"><span style="color:#393a34;">  .finally(() =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">    console.log(&#39;finally&#39;)</span></span>
<span class="line"><span style="color:#393a34;">  })</span></span>
<span class="line"><span style="color:#393a34;">Promise.resolve(&#39;2&#39;)</span></span>
<span class="line"><span style="color:#393a34;">  .finally(() =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">    console.log(&#39;finally2&#39;)</span></span>
<span class="line"><span style="color:#393a34;">    return &#39;我是finally2返回的值&#39;</span></span>
<span class="line"><span style="color:#393a34;">  })</span></span>
<span class="line"><span style="color:#393a34;">  .then(res =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">    console.log(&#39;finally2后面的then函数&#39;, res)</span></span>
<span class="line"><span style="color:#393a34;">  })</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>输出结果如下：</p><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">1</span></span>
<span class="line"><span style="color:#393a34;">finally2</span></span>
<span class="line"><span style="color:#393a34;">finally</span></span>
<span class="line"><span style="color:#393a34;">finally2后面的then函数 2</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><code>.finally()</code>一般用的很少，只要记住以下几点就可以了：</p><ul><li><code>.finally()</code>方法不管Promise对象最后的状态如何都会执行</li><li><code>.finally()</code>方法的回调函数不接受任何的参数，也就是说你在<code>.finally()</code>函数中是无法知道Promise最终的状态是<code>resolved</code>还是<code>rejected</code>的</li><li>它最终返回的默认会是一个上一次的Promise对象值，不过如果抛出的是一个异常则返回异常的Promise对象。</li><li>finally本质上是then方法的特例</li></ul><p><code>.finally()</code>的错误捕获：</p><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">Promise.resolve(&#39;1&#39;)</span></span>
<span class="line"><span style="color:#393a34;">  .finally(() =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">    console.log(&#39;finally1&#39;)</span></span>
<span class="line"><span style="color:#393a34;">    throw new Error(&#39;我是finally中抛出的异常&#39;)</span></span>
<span class="line"><span style="color:#393a34;">  })</span></span>
<span class="line"><span style="color:#393a34;">  .then(res =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">    console.log(&#39;finally后面的then函数&#39;, res)</span></span>
<span class="line"><span style="color:#393a34;">  })</span></span>
<span class="line"><span style="color:#393a34;">  .catch(err =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">    console.log(&#39;捕获错误&#39;, err)</span></span>
<span class="line"><span style="color:#393a34;">  })</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>输出结果为：</p><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">&#39;finally1&#39;</span></span>
<span class="line"><span style="color:#393a34;">&#39;捕获错误&#39; Error: 我是finally中抛出的异常</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="_14-代码输出结果" tabindex="-1">14. 代码输出结果 <a class="header-anchor" href="#_14-代码输出结果" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">function runAsync (x) {</span></span>
<span class="line"><span style="color:#393a34;">    const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000))</span></span>
<span class="line"><span style="color:#393a34;">    return p</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">Promise.all([runAsync(1), runAsync(2), runAsync(3)]).then(res =&gt; console.log(res))</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>输出结果如下：</p><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">1</span></span>
<span class="line"><span style="color:#393a34;">2</span></span>
<span class="line"><span style="color:#393a34;">3</span></span>
<span class="line"><span style="color:#393a34;">[1, 2, 3]</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>首先，定义了一个Promise，来异步执行函数runAsync，该函数传入一个值x，然后间隔一秒后打印出这个x。</p><p>之后再使用<code>Promise.all</code>来执行这个函数，执行的时候，看到一秒之后输出了1，2，3，同时输出了数组[1, 2, 3]，三个函数是同步执行的，并且在一个回调函数中返回了所有的结果。并且结果和函数的执行顺序是一致的。</p><h3 id="_15-代码输出结果" tabindex="-1">15. 代码输出结果 <a class="header-anchor" href="#_15-代码输出结果" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">function runAsync (x) {</span></span>
<span class="line"><span style="color:#393a34;">  const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000))</span></span>
<span class="line"><span style="color:#393a34;">  return p</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;">function runReject (x) {</span></span>
<span class="line"><span style="color:#393a34;">  const p = new Promise((res, rej) =&gt; setTimeout(() =&gt; rej(`Error: ${x}`, console.log(x)), 1000 * x))</span></span>
<span class="line"><span style="color:#393a34;">  return p</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;">Promise.all([runAsync(1), runReject(4), runAsync(3), runReject(2)])</span></span>
<span class="line"><span style="color:#393a34;">       .then(res =&gt; console.log(res))</span></span>
<span class="line"><span style="color:#393a34;">       .catch(err =&gt; console.log(err))</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>输出结果如下：</p><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">// 1s后输出</span></span>
<span class="line"><span style="color:#393a34;">1</span></span>
<span class="line"><span style="color:#393a34;">3</span></span>
<span class="line"><span style="color:#393a34;">// 2s后输出</span></span>
<span class="line"><span style="color:#393a34;">2</span></span>
<span class="line"><span style="color:#393a34;">Error: 2</span></span>
<span class="line"><span style="color:#393a34;">// 4s后输出</span></span>
<span class="line"><span style="color:#393a34;">4</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>可以看到。catch捕获到了第一个错误，在这道题目中最先的错误就是<code>runReject(2)</code>的结果。如果一组异步操作中有一个异常都不会进入<code>.then()</code>的第一个回调函数参数中。会被<code>.then()</code>的第二个回调函数捕获。</p><h3 id="_16-代码输出结果" tabindex="-1">16. 代码输出结果 <a class="header-anchor" href="#_16-代码输出结果" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">function runAsync (x) {</span></span>
<span class="line"><span style="color:#393a34;">  const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000))</span></span>
<span class="line"><span style="color:#393a34;">  return p</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;">Promise.race([runAsync(1), runAsync(2), runAsync(3)])</span></span>
<span class="line"><span style="color:#393a34;">  .then(res =&gt; console.log(&#39;result: &#39;, res))</span></span>
<span class="line"><span style="color:#393a34;">  .catch(err =&gt; console.log(err))</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>输出结果如下：</p><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">1</span></span>
<span class="line"><span style="color:#393a34;">&#39;result: &#39; 1</span></span>
<span class="line"><span style="color:#393a34;">2</span></span>
<span class="line"><span style="color:#393a34;">3</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>then只会捕获第一个成功的方法，其他的函数虽然还会继续执行，但是不是被then捕获了。</p><h3 id="_17-代码输出结果" tabindex="-1">17. 代码输出结果 <a class="header-anchor" href="#_17-代码输出结果" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">function runAsync(x) {</span></span>
<span class="line"><span style="color:#393a34;">  const p = new Promise(r =&gt;</span></span>
<span class="line"><span style="color:#393a34;">    setTimeout(() =&gt; r(x, console.log(x)), 1000)</span></span>
<span class="line"><span style="color:#393a34;">  );</span></span>
<span class="line"><span style="color:#393a34;">  return p;</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;">function runReject(x) {</span></span>
<span class="line"><span style="color:#393a34;">  const p = new Promise((res, rej) =&gt;</span></span>
<span class="line"><span style="color:#393a34;">    setTimeout(() =&gt; rej(`Error: ${x}`, console.log(x)), 1000 * x)</span></span>
<span class="line"><span style="color:#393a34;">  );</span></span>
<span class="line"><span style="color:#393a34;">  return p;</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;">Promise.race([runReject(0), runAsync(1), runAsync(2), runAsync(3)])</span></span>
<span class="line"><span style="color:#393a34;">  .then(res =&gt; console.log(&quot;result: &quot;, res))</span></span>
<span class="line"><span style="color:#393a34;">  .catch(err =&gt; console.log(err));</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>输出结果如下：</p><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">0</span></span>
<span class="line"><span style="color:#393a34;">Error: 0</span></span>
<span class="line"><span style="color:#393a34;">1</span></span>
<span class="line"><span style="color:#393a34;">2</span></span>
<span class="line"><span style="color:#393a34;">3</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>可以看到在catch捕获到第一个错误之后，后面的代码还不执行，不过不会再被捕获了。</p><p>注意：<code>all</code>和<code>race</code>传入的数组中如果有会抛出异常的异步任务，那么只有最先抛出的错误会被捕获，并且是被then的第二个参数或者后面的catch捕获；但并不会影响数组中其它的异步任务的执行。</p><h3 id="_18-代码输出结果" tabindex="-1">18. 代码输出结果 <a class="header-anchor" href="#_18-代码输出结果" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">async function async1() {</span></span>
<span class="line"><span style="color:#393a34;">  console.log(&quot;async1 start&quot;);</span></span>
<span class="line"><span style="color:#393a34;">  await async2();</span></span>
<span class="line"><span style="color:#393a34;">  console.log(&quot;async1 end&quot;);</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;">async function async2() {</span></span>
<span class="line"><span style="color:#393a34;">  console.log(&quot;async2&quot;);</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;">async1();</span></span>
<span class="line"><span style="color:#393a34;">console.log(&#39;start&#39;)</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>输出结果如下：</p><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">async1 start</span></span>
<span class="line"><span style="color:#393a34;">async2</span></span>
<span class="line"><span style="color:#393a34;">start</span></span>
<span class="line"><span style="color:#393a34;">async1 end</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>代码的执行过程如下：</p><ol><li>首先执行函数中的同步代码<code>async1 start</code>，之后遇到了<code>await</code>，它会阻塞<code>async1</code>后面代码的执行，因此会先去执行<code>async2</code>中的同步代码<code>async2</code>，然后跳出<code>async1</code>；</li><li>跳出<code>async1</code>函数后，执行同步代码<code>start</code>；</li><li>在一轮宏任务全部执行完之后，再来执行<code>await</code>后面的内容<code>async1 end</code>。</li></ol><p>这里可以理解为await后面的语句相当于放到了new Promise中，下一行及之后的语句相当于放在Promise.then中。</p><h3 id="_19-代码输出结果" tabindex="-1">19. 代码输出结果 <a class="header-anchor" href="#_19-代码输出结果" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">async function async1() {</span></span>
<span class="line"><span style="color:#393a34;">  console.log(&quot;async1 start&quot;);</span></span>
<span class="line"><span style="color:#393a34;">  await async2();</span></span>
<span class="line"><span style="color:#393a34;">  console.log(&quot;async1 end&quot;);</span></span>
<span class="line"><span style="color:#393a34;">  setTimeout(() =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">    console.log(&#39;timer1&#39;)</span></span>
<span class="line"><span style="color:#393a34;">  }, 0)</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;">async function async2() {</span></span>
<span class="line"><span style="color:#393a34;">  setTimeout(() =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">    console.log(&#39;timer2&#39;)</span></span>
<span class="line"><span style="color:#393a34;">  }, 0)</span></span>
<span class="line"><span style="color:#393a34;">  console.log(&quot;async2&quot;);</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;">async1();</span></span>
<span class="line"><span style="color:#393a34;">setTimeout(() =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">  console.log(&#39;timer3&#39;)</span></span>
<span class="line"><span style="color:#393a34;">}, 0)</span></span>
<span class="line"><span style="color:#393a34;">console.log(&quot;start&quot;)</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>输出结果如下：</p><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">async1 start</span></span>
<span class="line"><span style="color:#393a34;">async2</span></span>
<span class="line"><span style="color:#393a34;">start</span></span>
<span class="line"><span style="color:#393a34;">async1 end</span></span>
<span class="line"><span style="color:#393a34;">timer2</span></span>
<span class="line"><span style="color:#393a34;">timer3</span></span>
<span class="line"><span style="color:#393a34;">timer1</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>代码的执行过程如下：</p><ol><li>首先进入<code>async1</code>，打印出<code>async1 start</code>；</li><li>之后遇到<code>async2</code>，进入<code>async2</code>，遇到定时器<code>timer2</code>，加入宏任务队列，之后打印<code>async2</code>；</li><li>由于<code>async2</code>阻塞了后面代码的执行，所以执行后面的定时器<code>timer3</code>，将其加入宏任务队列，之后打印<code>start</code>；</li><li>然后执行async2后面的代码，打印出<code>async1 end</code>，遇到定时器timer1，将其加入宏任务队列；</li><li>最后，宏任务队列有三个任务，先后顺序为<code>timer2</code>，<code>timer3</code>，<code>timer1</code>，没有微任务，所以直接所有的宏任务按照先进先出的原则执行。</li></ol><h3 id="_20-代码输出结果" tabindex="-1">20. 代码输出结果 <a class="header-anchor" href="#_20-代码输出结果" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">async function async1 () {</span></span>
<span class="line"><span style="color:#393a34;">  console.log(&#39;async1 start&#39;);</span></span>
<span class="line"><span style="color:#393a34;">  await new Promise(resolve =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">    console.log(&#39;promise1&#39;)</span></span>
<span class="line"><span style="color:#393a34;">  })</span></span>
<span class="line"><span style="color:#393a34;">  console.log(&#39;async1 success&#39;);</span></span>
<span class="line"><span style="color:#393a34;">  return &#39;async1 end&#39;</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;">console.log(&#39;srcipt start&#39;)</span></span>
<span class="line"><span style="color:#393a34;">async1().then(res =&gt; console.log(res))</span></span>
<span class="line"><span style="color:#393a34;">console.log(&#39;srcipt end&#39;)</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>输出结果如下：</p><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">script start</span></span>
<span class="line"><span style="color:#393a34;">async1 start</span></span>
<span class="line"><span style="color:#393a34;">promise1</span></span>
<span class="line"><span style="color:#393a34;">script end</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>这里需要注意的是在<code>async1</code>中<code>await</code>后面的Promise是没有返回值的，也就是它的状态始终是<code>pending</code>状态，所以在<code>await</code>之后的内容是不会执行的，包括<code>async1</code>后面的 <code>.then</code>。</p><h3 id="_21-代码输出结果" tabindex="-1">21. 代码输出结果 <a class="header-anchor" href="#_21-代码输出结果" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">async function async1 () {</span></span>
<span class="line"><span style="color:#393a34;">  console.log(&#39;async1 start&#39;);</span></span>
<span class="line"><span style="color:#393a34;">  await new Promise(resolve =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">    console.log(&#39;promise1&#39;)</span></span>
<span class="line"><span style="color:#393a34;">    resolve(&#39;promise1 resolve&#39;)</span></span>
<span class="line"><span style="color:#393a34;">  }).then(res =&gt; console.log(res))</span></span>
<span class="line"><span style="color:#393a34;">  console.log(&#39;async1 success&#39;);</span></span>
<span class="line"><span style="color:#393a34;">  return &#39;async1 end&#39;</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;">console.log(&#39;srcipt start&#39;)</span></span>
<span class="line"><span style="color:#393a34;">async1().then(res =&gt; console.log(res))</span></span>
<span class="line"><span style="color:#393a34;">console.log(&#39;srcipt end&#39;)</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>这里是对上面一题进行了改造，加上了resolve。</p><p>输出结果如下：</p><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">script start</span></span>
<span class="line"><span style="color:#393a34;">async1 start</span></span>
<span class="line"><span style="color:#393a34;">promise1</span></span>
<span class="line"><span style="color:#393a34;">script end</span></span>
<span class="line"><span style="color:#393a34;">promise1 resolve</span></span>
<span class="line"><span style="color:#393a34;">async1 success</span></span>
<span class="line"><span style="color:#393a34;">async1 end</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="_22-代码输出结果" tabindex="-1">22. 代码输出结果 <a class="header-anchor" href="#_22-代码输出结果" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">async function async1() {</span></span>
<span class="line"><span style="color:#393a34;">  console.log(&quot;async1 start&quot;);</span></span>
<span class="line"><span style="color:#393a34;">  await async2();</span></span>
<span class="line"><span style="color:#393a34;">  console.log(&quot;async1 end&quot;);</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">async function async2() {</span></span>
<span class="line"><span style="color:#393a34;">  console.log(&quot;async2&quot;);</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">console.log(&quot;script start&quot;);</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">setTimeout(function() {</span></span>
<span class="line"><span style="color:#393a34;">  console.log(&quot;setTimeout&quot;);</span></span>
<span class="line"><span style="color:#393a34;">}, 0);</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">async1();</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">new Promise(resolve =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">  console.log(&quot;promise1&quot;);</span></span>
<span class="line"><span style="color:#393a34;">  resolve();</span></span>
<span class="line"><span style="color:#393a34;">}).then(function() {</span></span>
<span class="line"><span style="color:#393a34;">  console.log(&quot;promise2&quot;);</span></span>
<span class="line"><span style="color:#393a34;">});</span></span>
<span class="line"><span style="color:#393a34;">console.log(&#39;script end&#39;)</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>输出结果如下：</p><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">script start</span></span>
<span class="line"><span style="color:#393a34;">async1 start</span></span>
<span class="line"><span style="color:#393a34;">async2</span></span>
<span class="line"><span style="color:#393a34;">promise1</span></span>
<span class="line"><span style="color:#393a34;">script end</span></span>
<span class="line"><span style="color:#393a34;">async1 end</span></span>
<span class="line"><span style="color:#393a34;">promise2</span></span>
<span class="line"><span style="color:#393a34;">setTimeout</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>代码执行过程如下：</p><ol><li>开头定义了async1和async2两个函数，但是并未执行，执行script中的代码，所以打印出script start；</li><li>遇到定时器Settimeout，它是一个宏任务，将其加入到宏任务队列；</li><li>之后执行函数async1，首先打印出async1 start；</li><li>遇到await，执行async2，打印出async2，并阻断后面代码的执行，将后面的代码加入到微任务队列；</li><li>然后跳出async1和async2，遇到Promise，打印出promise1；</li><li>遇到resolve，将其加入到微任务队列，然后执行后面的script代码，打印出script end；</li><li>之后就该执行微任务队列了，首先打印出async1 end，然后打印出promise2；</li><li>执行完微任务队列，就开始执行宏任务队列中的定时器，打印出setTimeout。</li></ol><h3 id="_23-代码输出结果" tabindex="-1">23. 代码输出结果 <a class="header-anchor" href="#_23-代码输出结果" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">async function async1 () {</span></span>
<span class="line"><span style="color:#393a34;">  await async2();</span></span>
<span class="line"><span style="color:#393a34;">  console.log(&#39;async1&#39;);</span></span>
<span class="line"><span style="color:#393a34;">  return &#39;async1 success&#39;</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;">async function async2 () {</span></span>
<span class="line"><span style="color:#393a34;">  return new Promise((resolve, reject) =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">    console.log(&#39;async2&#39;)</span></span>
<span class="line"><span style="color:#393a34;">    reject(&#39;error&#39;)</span></span>
<span class="line"><span style="color:#393a34;">  })</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;">async1().then(res =&gt; console.log(res))</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>输出结果如下：</p><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">async2</span></span>
<span class="line"><span style="color:#393a34;">Uncaught (in promise) error</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>可以看到，如果async函数中抛出了错误，就会终止错误结果，不会继续向下执行。</p><p>如果想要让错误不足之处后面的代码执行，可以使用catch来捕获：</p><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">async function async1 () {</span></span>
<span class="line"><span style="color:#393a34;">  await Promise.reject(&#39;error!!!&#39;).catch(e =&gt; console.log(e))</span></span>
<span class="line"><span style="color:#393a34;">  console.log(&#39;async1&#39;);</span></span>
<span class="line"><span style="color:#393a34;">  return Promise.resolve(&#39;async1 success&#39;)</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;">async1().then(res =&gt; console.log(res))</span></span>
<span class="line"><span style="color:#393a34;">console.log(&#39;script start&#39;)</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>这样的输出结果就是：</p><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">script start</span></span>
<span class="line"><span style="color:#393a34;">error!!!</span></span>
<span class="line"><span style="color:#393a34;">async1</span></span>
<span class="line"><span style="color:#393a34;">async1 success</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="_24-代码输出结果" tabindex="-1">24. 代码输出结果 <a class="header-anchor" href="#_24-代码输出结果" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">const first = () =&gt; (new Promise((resolve, reject) =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">    console.log(3);</span></span>
<span class="line"><span style="color:#393a34;">    let p = new Promise((resolve, reject) =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">        console.log(7);</span></span>
<span class="line"><span style="color:#393a34;">        setTimeout(() =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">            console.log(5);</span></span>
<span class="line"><span style="color:#393a34;">            resolve(6);</span></span>
<span class="line"><span style="color:#393a34;">            console.log(p)</span></span>
<span class="line"><span style="color:#393a34;">        }, 0)</span></span>
<span class="line"><span style="color:#393a34;">        resolve(1);</span></span>
<span class="line"><span style="color:#393a34;">    });</span></span>
<span class="line"><span style="color:#393a34;">    resolve(2);</span></span>
<span class="line"><span style="color:#393a34;">    p.then((arg) =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">        console.log(arg);</span></span>
<span class="line"><span style="color:#393a34;">    });</span></span>
<span class="line"><span style="color:#393a34;">}));</span></span>
<span class="line"><span style="color:#393a34;">first().then((arg) =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">    console.log(arg);</span></span>
<span class="line"><span style="color:#393a34;">});</span></span>
<span class="line"><span style="color:#393a34;">console.log(4);</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>输出结果如下：</p><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">3</span></span>
<span class="line"><span style="color:#393a34;">7</span></span>
<span class="line"><span style="color:#393a34;">4</span></span>
<span class="line"><span style="color:#393a34;">1</span></span>
<span class="line"><span style="color:#393a34;">2</span></span>
<span class="line"><span style="color:#393a34;">5</span></span>
<span class="line"><span style="color:#393a34;">Promise{&lt;resolved&gt;: 1}</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>代码的执行过程如下：</p><ol><li>首先会进入Promise，打印出3，之后进入下面的Promise，打印出7；</li><li>遇到了定时器，将其加入宏任务队列；</li><li>执行Promise p中的resolve，状态变为resolved，返回值为1；</li><li>执行Promise first中的resolve，状态变为resolved，返回值为2；</li><li>遇到p.then，将其加入微任务队列，遇到first().then，将其加入任务队列；</li><li>执行外面的代码，打印出4；</li><li>这样第一轮宏任务就执行完了，开始执行微任务队列中的任务，先后打印出1和2；</li><li>这样微任务就执行完了，开始执行下一轮宏任务，宏任务队列中有一个定时器，执行它，打印出5，由于执行已经变为resolved状态，所以<code>resolve(6)</code>不会再执行；</li><li>最后<code>console.log(p)</code>打印出<code>Promise{&lt;resolved&gt;: 1}</code>；</li></ol><h3 id="_25-代码输出结果" tabindex="-1">25. 代码输出结果 <a class="header-anchor" href="#_25-代码输出结果" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">const async1 = async () =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">  console.log(&#39;async1&#39;);</span></span>
<span class="line"><span style="color:#393a34;">  setTimeout(() =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">    console.log(&#39;timer1&#39;)</span></span>
<span class="line"><span style="color:#393a34;">  }, 2000)</span></span>
<span class="line"><span style="color:#393a34;">  await new Promise(resolve =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">    console.log(&#39;promise1&#39;)</span></span>
<span class="line"><span style="color:#393a34;">  })</span></span>
<span class="line"><span style="color:#393a34;">  console.log(&#39;async1 end&#39;)</span></span>
<span class="line"><span style="color:#393a34;">  return &#39;async1 success&#39;</span></span>
<span class="line"><span style="color:#393a34;">} </span></span>
<span class="line"><span style="color:#393a34;">console.log(&#39;script start&#39;);</span></span>
<span class="line"><span style="color:#393a34;">async1().then(res =&gt; console.log(res));</span></span>
<span class="line"><span style="color:#393a34;">console.log(&#39;script end&#39;);</span></span>
<span class="line"><span style="color:#393a34;">Promise.resolve(1)</span></span>
<span class="line"><span style="color:#393a34;">  .then(2)</span></span>
<span class="line"><span style="color:#393a34;">  .then(Promise.resolve(3))</span></span>
<span class="line"><span style="color:#393a34;">  .catch(4)</span></span>
<span class="line"><span style="color:#393a34;">  .then(res =&gt; console.log(res))</span></span>
<span class="line"><span style="color:#393a34;">setTimeout(() =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">  console.log(&#39;timer2&#39;)</span></span>
<span class="line"><span style="color:#393a34;">}, 1000)</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>输出结果如下：</p><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">script start</span></span>
<span class="line"><span style="color:#393a34;">async1</span></span>
<span class="line"><span style="color:#393a34;">promise1</span></span>
<span class="line"><span style="color:#393a34;">script end</span></span>
<span class="line"><span style="color:#393a34;">1</span></span>
<span class="line"><span style="color:#393a34;">timer2</span></span>
<span class="line"><span style="color:#393a34;">timer1</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>代码的执行过程如下：</p><ol><li>首先执行同步带吗，打印出script start；</li><li>遇到定时器timer1将其加入宏任务队列；</li><li>之后是执行Promise，打印出promise1，由于Promise没有返回值，所以后面的代码不会执行；</li><li>然后执行同步代码，打印出script end；</li><li>继续执行下面的Promise，.then和.catch期望参数是一个函数，这里传入的是一个数字，因此就会发生值渗透，将resolve(1)的值传到最后一个then，直接打印出1；</li><li>遇到第二个定时器，将其加入到微任务队列，执行微任务队列，按顺序依次执行两个定时器，但是由于定时器时间的原因，会在两秒后先打印出timer2，在四秒后打印出timer1。</li></ol><h3 id="_26-代码输出结果" tabindex="-1">26. 代码输出结果 <a class="header-anchor" href="#_26-代码输出结果" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">const p1 = new Promise((resolve) =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">  setTimeout(() =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">    resolve(&#39;resolve3&#39;);</span></span>
<span class="line"><span style="color:#393a34;">    console.log(&#39;timer1&#39;)</span></span>
<span class="line"><span style="color:#393a34;">  }, 0)</span></span>
<span class="line"><span style="color:#393a34;">  resolve(&#39;resovle1&#39;);</span></span>
<span class="line"><span style="color:#393a34;">  resolve(&#39;resolve2&#39;);</span></span>
<span class="line"><span style="color:#393a34;">}).then(res =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">  console.log(res)  // resolve1</span></span>
<span class="line"><span style="color:#393a34;">  setTimeout(() =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">    console.log(p1)</span></span>
<span class="line"><span style="color:#393a34;">  }, 1000)</span></span>
<span class="line"><span style="color:#393a34;">}).finally(res =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">  console.log(&#39;finally&#39;, res)</span></span>
<span class="line"><span style="color:#393a34;">})</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>执行结果为如下：</p><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">resolve1</span></span>
<span class="line"><span style="color:#393a34;">finally  undefined</span></span>
<span class="line"><span style="color:#393a34;">timer1</span></span>
<span class="line"><span style="color:#393a34;">Promise{&lt;resolved&gt;: undefined}</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="_27-代码输出结果" tabindex="-1">27. 代码输出结果 <a class="header-anchor" href="#_27-代码输出结果" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">console.log(&#39;1&#39;);</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">setTimeout(function() {</span></span>
<span class="line"><span style="color:#393a34;">    console.log(&#39;2&#39;);</span></span>
<span class="line"><span style="color:#393a34;">    process.nextTick(function() {</span></span>
<span class="line"><span style="color:#393a34;">        console.log(&#39;3&#39;);</span></span>
<span class="line"><span style="color:#393a34;">    })</span></span>
<span class="line"><span style="color:#393a34;">    new Promise(function(resolve) {</span></span>
<span class="line"><span style="color:#393a34;">        console.log(&#39;4&#39;);</span></span>
<span class="line"><span style="color:#393a34;">        resolve();</span></span>
<span class="line"><span style="color:#393a34;">    }).then(function() {</span></span>
<span class="line"><span style="color:#393a34;">        console.log(&#39;5&#39;)</span></span>
<span class="line"><span style="color:#393a34;">    })</span></span>
<span class="line"><span style="color:#393a34;">})</span></span>
<span class="line"><span style="color:#393a34;">process.nextTick(function() {</span></span>
<span class="line"><span style="color:#393a34;">    console.log(&#39;6&#39;);</span></span>
<span class="line"><span style="color:#393a34;">})</span></span>
<span class="line"><span style="color:#393a34;">new Promise(function(resolve) {</span></span>
<span class="line"><span style="color:#393a34;">    console.log(&#39;7&#39;);</span></span>
<span class="line"><span style="color:#393a34;">    resolve();</span></span>
<span class="line"><span style="color:#393a34;">}).then(function() {</span></span>
<span class="line"><span style="color:#393a34;">    console.log(&#39;8&#39;)</span></span>
<span class="line"><span style="color:#393a34;">})</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">setTimeout(function() {</span></span>
<span class="line"><span style="color:#393a34;">    console.log(&#39;9&#39;);</span></span>
<span class="line"><span style="color:#393a34;">    process.nextTick(function() {</span></span>
<span class="line"><span style="color:#393a34;">        console.log(&#39;10&#39;);</span></span>
<span class="line"><span style="color:#393a34;">    })</span></span>
<span class="line"><span style="color:#393a34;">    new Promise(function(resolve) {</span></span>
<span class="line"><span style="color:#393a34;">        console.log(&#39;11&#39;);</span></span>
<span class="line"><span style="color:#393a34;">        resolve();</span></span>
<span class="line"><span style="color:#393a34;">    }).then(function() {</span></span>
<span class="line"><span style="color:#393a34;">        console.log(&#39;12&#39;)</span></span>
<span class="line"><span style="color:#393a34;">    })</span></span>
<span class="line"><span style="color:#393a34;">})</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br></div></div><p>输出结果如下：</p><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">1</span></span>
<span class="line"><span style="color:#393a34;">7</span></span>
<span class="line"><span style="color:#393a34;">6</span></span>
<span class="line"><span style="color:#393a34;">8</span></span>
<span class="line"><span style="color:#393a34;">2</span></span>
<span class="line"><span style="color:#393a34;">4</span></span>
<span class="line"><span style="color:#393a34;">3</span></span>
<span class="line"><span style="color:#393a34;">5</span></span>
<span class="line"><span style="color:#393a34;">9</span></span>
<span class="line"><span style="color:#393a34;">11</span></span>
<span class="line"><span style="color:#393a34;">10</span></span>
<span class="line"><span style="color:#393a34;">12</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p><strong>（1）第一轮事件循环流程分析如下：</strong></p><ul><li>整体script作为第一个宏任务进入主线程，遇到<code>console.log</code>，输出1。</li><li>遇到<code>setTimeout</code>，其回调函数被分发到宏任务Event Queue中。暂且记为<code>setTimeout1</code>。</li><li>遇到<code>process.nextTick()</code>，其回调函数被分发到微任务Event Queue中。记为<code>process1</code>。</li><li>遇到<code>Promise</code>，<code>new Promise</code>直接执行，输出7。<code>then</code>被分发到微任务Event Queue中。记为<code>then1</code>。</li><li>又遇到了<code>setTimeout</code>，其回调函数被分发到宏任务Event Queue中，记为<code>setTimeout2</code>。</li></ul><table><thead><tr><th>宏任务Event Queue</th><th>微任务Event Queue</th></tr></thead><tbody><tr><td>setTimeout1</td><td>process1</td></tr><tr><td>setTimeout2</td><td>then1</td></tr></tbody></table><p>上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。发现了<code>process1</code>和<code>then1</code>两个微任务：</p><ul><li>执行<code>process1</code>，输出6。</li><li>执行<code>then1</code>，输出8。</li></ul><p>第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。</p><p><strong>（2）第二轮时间循环从</strong><code>**setTimeout1**</code><strong>宏任务开始：</strong></p><ul><li>首先输出2。接下来遇到了<code>process.nextTick()</code>，同样将其分发到微任务Event Queue中，记为<code>process2</code>。</li><li><code>new Promise</code>立即执行输出4，<code>then</code>也分发到微任务Event Queue中，记为<code>then2</code>。</li></ul><table><thead><tr><th>宏任务Event Queue</th><th>微任务Event Queue</th></tr></thead><tbody><tr><td>setTimeout2</td><td>process2</td></tr><tr><td></td><td>then2</td></tr></tbody></table><p>第二轮事件循环宏任务结束，发现有<code>process2</code>和<code>then2</code>两个微任务可以执行：</p><ul><li>输出3。</li><li>输出5。</li></ul><p>第二轮事件循环结束，第二轮输出2，4，3，5。</p><p><strong>（3）第三轮事件循环开始，此时只剩setTimeout2了，执行。</strong></p><ul><li>直接输出9。</li><li>将<code>process.nextTick()</code>分发到微任务Event Queue中。记为<code>process3</code>。</li><li>直接执行<code>new Promise</code>，输出11。</li><li>将<code>then</code>分发到微任务Event Queue中，记为<code>then3</code>。</li></ul><table><thead><tr><th>宏任务Event Queue</th><th>微任务Event Queue</th></tr></thead><tbody><tr><td></td><td>process3</td></tr><tr><td></td><td>then3</td></tr></tbody></table><p>第三轮事件循环宏任务执行结束，执行两个微任务<code>process3</code>和<code>then3</code>：</p><ul><li>输出10。</li><li>输出12。</li></ul><p>第三轮事件循环结束，第三轮输出9，11，10，12。</p><p>整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。</p><h3 id="_28-代码输出结果" tabindex="-1">28. 代码输出结果 <a class="header-anchor" href="#_28-代码输出结果" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">console.log(1)</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">setTimeout(() =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">  console.log(2)</span></span>
<span class="line"><span style="color:#393a34;">})</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">new Promise(resolve =&gt;  {</span></span>
<span class="line"><span style="color:#393a34;">  console.log(3)</span></span>
<span class="line"><span style="color:#393a34;">  resolve(4)</span></span>
<span class="line"><span style="color:#393a34;">}).then(d =&gt; console.log(d))</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">setTimeout(() =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">  console.log(5)</span></span>
<span class="line"><span style="color:#393a34;">  new Promise(resolve =&gt;  {</span></span>
<span class="line"><span style="color:#393a34;">    resolve(6)</span></span>
<span class="line"><span style="color:#393a34;">  }).then(d =&gt; console.log(d))</span></span>
<span class="line"><span style="color:#393a34;">})</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">setTimeout(() =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">  console.log(7)</span></span>
<span class="line"><span style="color:#393a34;">})</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">console.log(8)</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p>输出结果如下：</p><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">1</span></span>
<span class="line"><span style="color:#393a34;">3</span></span>
<span class="line"><span style="color:#393a34;">8</span></span>
<span class="line"><span style="color:#393a34;">4</span></span>
<span class="line"><span style="color:#393a34;">2</span></span>
<span class="line"><span style="color:#393a34;">5</span></span>
<span class="line"><span style="color:#393a34;">6</span></span>
<span class="line"><span style="color:#393a34;">7</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>代码执行过程如下：</p><ol><li>首先执行script代码，打印出1；</li><li>遇到第一个定时器，加入到宏任务队列；</li><li>遇到Promise，执行代码，打印出3，遇到resolve，将其加入到微任务队列；</li><li>遇到第二个定时器，加入到宏任务队列；</li><li>遇到第三个定时器，加入到宏任务队列；</li><li>继续执行script代码，打印出8，第一轮执行结束；</li><li>执行微任务队列，打印出第一个Promise的resolve结果：4；</li><li>开始执行宏任务队列，执行第一个定时器，打印出2；</li><li>此时没有微任务，继续执行宏任务中的第二个定时器，首先打印出5，遇到Promise，首选打印出6，遇到resolve，将其加入到微任务队列；</li><li>执行微任务队列，打印出6；</li><li>执行宏任务队列中的最后一个定时器，打印出7。</li></ol><h3 id="_29-代码输出结果" tabindex="-1">29. 代码输出结果 <a class="header-anchor" href="#_29-代码输出结果" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">console.log(1);</span></span>
<span class="line"><span style="color:#393a34;">    </span></span>
<span class="line"><span style="color:#393a34;">setTimeout(() =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">  console.log(2);</span></span>
<span class="line"><span style="color:#393a34;">  Promise.resolve().then(() =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">    console.log(3)</span></span>
<span class="line"><span style="color:#393a34;">  });</span></span>
<span class="line"><span style="color:#393a34;">});</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">new Promise((resolve, reject) =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">  console.log(4)</span></span>
<span class="line"><span style="color:#393a34;">  resolve(5)</span></span>
<span class="line"><span style="color:#393a34;">}).then((data) =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">  console.log(data);</span></span>
<span class="line"><span style="color:#393a34;">})</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">setTimeout(() =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">  console.log(6);</span></span>
<span class="line"><span style="color:#393a34;">})</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">console.log(7);</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>代码输出结果如下：</p><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">1</span></span>
<span class="line"><span style="color:#393a34;">4</span></span>
<span class="line"><span style="color:#393a34;">7</span></span>
<span class="line"><span style="color:#393a34;">5</span></span>
<span class="line"><span style="color:#393a34;">2</span></span>
<span class="line"><span style="color:#393a34;">3</span></span>
<span class="line"><span style="color:#393a34;">6</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>代码执行过程如下：</p><ol><li>首先执行scrip代码，打印出1；</li><li>遇到第一个定时器setTimeout，将其加入到宏任务队列；</li><li>遇到Promise，执行里面的同步代码，打印出4，遇到resolve，将其加入到微任务队列；</li><li>遇到第二个定时器setTimeout，将其加入到红任务队列；</li><li>执行script代码，打印出7，至此第一轮执行完成；</li><li>指定微任务队列中的代码，打印出resolve的结果：5；</li><li>执行宏任务中的第一个定时器setTimeout，首先打印出2，然后遇到 Promise.resolve().then()，将其加入到微任务队列；</li><li>执行完这个宏任务，就开始执行微任务队列，打印出3；</li><li>继续执行宏任务队列中的第二个定时器，打印出6。</li></ol><h3 id="_30-代码输出结果" tabindex="-1">30. 代码输出结果 <a class="header-anchor" href="#_30-代码输出结果" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">Promise.resolve().then(() =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">    console.log(&#39;1&#39;);</span></span>
<span class="line"><span style="color:#393a34;">    throw &#39;Error&#39;;</span></span>
<span class="line"><span style="color:#393a34;">}).then(() =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">    console.log(&#39;2&#39;);</span></span>
<span class="line"><span style="color:#393a34;">}).catch(() =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">    console.log(&#39;3&#39;);</span></span>
<span class="line"><span style="color:#393a34;">    throw &#39;Error&#39;;</span></span>
<span class="line"><span style="color:#393a34;">}).then(() =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">    console.log(&#39;4&#39;);</span></span>
<span class="line"><span style="color:#393a34;">}).catch(() =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">    console.log(&#39;5&#39;);</span></span>
<span class="line"><span style="color:#393a34;">}).then(() =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">    console.log(&#39;6&#39;);</span></span>
<span class="line"><span style="color:#393a34;">});</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>执行结果如下：</p><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">1 </span></span>
<span class="line"><span style="color:#393a34;">3 </span></span>
<span class="line"><span style="color:#393a34;">5 </span></span>
<span class="line"><span style="color:#393a34;">6</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>在这道题目中，我们需要知道，无论是thne还是catch中，只要throw 抛出了错误，就会被catch捕获，如果没有throw出错误，就被继续执行后面的then。</p><h3 id="_31-代码输出结果" tabindex="-1">31. 代码输出结果 <a class="header-anchor" href="#_31-代码输出结果" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">setTimeout(function () {</span></span>
<span class="line"><span style="color:#393a34;">  console.log(1);</span></span>
<span class="line"><span style="color:#393a34;">}, 100);</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">new Promise(function (resolve) {</span></span>
<span class="line"><span style="color:#393a34;">  console.log(2);</span></span>
<span class="line"><span style="color:#393a34;">  resolve();</span></span>
<span class="line"><span style="color:#393a34;">  console.log(3);</span></span>
<span class="line"><span style="color:#393a34;">}).then(function () {</span></span>
<span class="line"><span style="color:#393a34;">  console.log(4);</span></span>
<span class="line"><span style="color:#393a34;">  new Promise((resove, reject) =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">    console.log(5);</span></span>
<span class="line"><span style="color:#393a34;">    setTimeout(() =&gt;  {</span></span>
<span class="line"><span style="color:#393a34;">      console.log(6);</span></span>
<span class="line"><span style="color:#393a34;">    }, 10);</span></span>
<span class="line"><span style="color:#393a34;">  })</span></span>
<span class="line"><span style="color:#393a34;">});</span></span>
<span class="line"><span style="color:#393a34;">console.log(7);</span></span>
<span class="line"><span style="color:#393a34;">console.log(8);</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>输出结果为：</p><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">2</span></span>
<span class="line"><span style="color:#393a34;">3</span></span>
<span class="line"><span style="color:#393a34;">7</span></span>
<span class="line"><span style="color:#393a34;">8</span></span>
<span class="line"><span style="color:#393a34;">4</span></span>
<span class="line"><span style="color:#393a34;">5</span></span>
<span class="line"><span style="color:#393a34;">6</span></span>
<span class="line"><span style="color:#393a34;">1</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>代码执行过程如下：</p><ol><li>首先遇到定时器，将其加入到宏任务队列；</li><li>遇到Promise，首先执行里面的同步代码，打印出2，遇到resolve，将其加入到微任务队列，执行后面同步代码，打印出3；</li><li>继续执行script中的代码，打印出7和8，至此第一轮代码执行完成；</li><li>执行微任务队列中的代码，首先打印出4，如遇到Promise，执行其中的同步代码，打印出5，遇到定时器，将其加入到宏任务队列中，此时宏任务队列中有两个定时器；</li><li>执行宏任务队列中的代码，这里我们需要注意是的第一个定时器的时间为100ms，第二个定时器的时间为10ms，所以先执行第二个定时器，打印出6；</li><li>此时微任务队列为空，继续执行宏任务队列，打印出1。</li></ol><p>做完这道题目，我们就需要格外注意，每个定时器的时间，并不是所有定时器的时间都为0哦。</p><h2 id="二、this" tabindex="-1">二、this <a class="header-anchor" href="#二、this" aria-hidden="true">#</a></h2><h3 id="_1-代码输出结果-1" tabindex="-1">1. 代码输出结果 <a class="header-anchor" href="#_1-代码输出结果-1" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">function foo() {</span></span>
<span class="line"><span style="color:#393a34;">  console.log( this.a );</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">function doFoo() {</span></span>
<span class="line"><span style="color:#393a34;">  foo();</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">var obj = {</span></span>
<span class="line"><span style="color:#393a34;">  a: 1,</span></span>
<span class="line"><span style="color:#393a34;">  doFoo: doFoo</span></span>
<span class="line"><span style="color:#393a34;">};</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">var a = 2; </span></span>
<span class="line"><span style="color:#393a34;">obj.doFoo()</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>输出结果：2</p><p>在Javascript中，this指向函数执行时的当前对象。在执行foo的时候，执行环境就是doFoo函数，执行环境为全局。所以，foo中的this是指向window的，所以会打印出2。</p><h3 id="_2-代码输出结果-1" tabindex="-1">2. 代码输出结果 <a class="header-anchor" href="#_2-代码输出结果-1" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">var a = 10</span></span>
<span class="line"><span style="color:#393a34;">var obj = {</span></span>
<span class="line"><span style="color:#393a34;">  a: 20,</span></span>
<span class="line"><span style="color:#393a34;">  say: () =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">    console.log(this.a)</span></span>
<span class="line"><span style="color:#393a34;">  }</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;">obj.say() </span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">var anotherObj = { a: 30 } </span></span>
<span class="line"><span style="color:#393a34;">obj.say.apply(anotherObj) </span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>输出结果：10 10</p><p>我么知道，箭头函数时不绑定this的，它的this来自原其父级所处的上下文，所以首先会打印全局中的 a 的值10。后面虽然让say方法指向了另外一个对象，但是仍不能改变箭头函数的特性，它的this仍然是指向全局的，所以依旧会输出10。</p><p>但是，如果是普通函数，那么就会有完全不一样的结果：</p><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">var a = 10  </span></span>
<span class="line"><span style="color:#393a34;">var obj = {  </span></span>
<span class="line"><span style="color:#393a34;">  a: 20,  </span></span>
<span class="line"><span style="color:#393a34;">  say(){</span></span>
<span class="line"><span style="color:#393a34;">    console.log(this.a)  </span></span>
<span class="line"><span style="color:#393a34;">  }  </span></span>
<span class="line"><span style="color:#393a34;">}  </span></span>
<span class="line"><span style="color:#393a34;">obj.say()   </span></span>
<span class="line"><span style="color:#393a34;">var anotherObj={a:30}   </span></span>
<span class="line"><span style="color:#393a34;">obj.say.apply(anotherObj)</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>输出结果：20 30</p><p>这时，say方法中的this就会指向他所在的对象，输出其中的a的值。</p><h3 id="_3-代码输出结果-1" tabindex="-1">3. 代码输出结果 <a class="header-anchor" href="#_3-代码输出结果-1" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">function a() {</span></span>
<span class="line"><span style="color:#393a34;">  console.log(this);</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;">a.call(null);</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>打印结果：window对象</p><p>根据ECMAScript262规范规定：如果第一个参数传入的对象调用者是null或者undefined，call方法将把全局对象（浏览器上是window对象）作为this的值。所以，不管传入null 还是 undefined，其this都是全局对象window。所以，在浏览器上答案是输出 window 对象。</p><p>要注意的是，在严格模式中，null 就是 null，undefined 就是 undefined：</p><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">&#39;use strict&#39;;</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">function a() {</span></span>
<span class="line"><span style="color:#393a34;">    console.log(this);</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;">a.call(null); // null</span></span>
<span class="line"><span style="color:#393a34;">a.call(undefined); // undefined</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="_4-代码输出结果-1" tabindex="-1">4. 代码输出结果 <a class="header-anchor" href="#_4-代码输出结果-1" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">var obj = { </span></span>
<span class="line"><span style="color:#393a34;">  name: &#39;cuggz&#39;, </span></span>
<span class="line"><span style="color:#393a34;">  fun: function(){ </span></span>
<span class="line"><span style="color:#393a34;">     console.log(this.name); </span></span>
<span class="line"><span style="color:#393a34;">  } </span></span>
<span class="line"><span style="color:#393a34;">} </span></span>
<span class="line"><span style="color:#393a34;">obj.fun()     // cuggz</span></span>
<span class="line"><span style="color:#393a34;">new obj.fun() // undefined</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="_6-代码输出结果-1" tabindex="-1">6. 代码输出结果 <a class="header-anchor" href="#_6-代码输出结果-1" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">var obj = {</span></span>
<span class="line"><span style="color:#393a34;">   say: function() {</span></span>
<span class="line"><span style="color:#393a34;">     var f1 = () =&gt;  {</span></span>
<span class="line"><span style="color:#393a34;">       console.log(&quot;1111&quot;, this);</span></span>
<span class="line"><span style="color:#393a34;">     }</span></span>
<span class="line"><span style="color:#393a34;">     f1();</span></span>
<span class="line"><span style="color:#393a34;">   },</span></span>
<span class="line"><span style="color:#393a34;">   pro: {</span></span>
<span class="line"><span style="color:#393a34;">     getPro:() =&gt;  {</span></span>
<span class="line"><span style="color:#393a34;">        console.log(this);</span></span>
<span class="line"><span style="color:#393a34;">     }</span></span>
<span class="line"><span style="color:#393a34;">   }</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;">var o = obj.say;</span></span>
<span class="line"><span style="color:#393a34;">o();</span></span>
<span class="line"><span style="color:#393a34;">obj.say();</span></span>
<span class="line"><span style="color:#393a34;">obj.pro.getPro();</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>输出结果：</p><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">1111 window对象</span></span>
<span class="line"><span style="color:#393a34;">1111 obj对象</span></span>
<span class="line"><span style="color:#393a34;">window对象</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>解析：</strong></p><ol><li>o()，o是在全局执行的，而f1是箭头函数，它是没有绑定this的，它的this指向其父级的this，其父级say方法的this指向的是全局作用域，所以会打印出window；</li><li>obj.say()，谁调用say，say 的this就指向谁，所以此时this指向的是obj对象；</li><li>obj.pro.getPro()，我们知道，箭头函数时不绑定this的，getPro处于pro中，而对象不构成单独的作用域，所以箭头的函数的this就指向了全局作用域window。</li></ol><h3 id="_7-代码输出结果-1" tabindex="-1">7. 代码输出结果 <a class="header-anchor" href="#_7-代码输出结果-1" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">var myObject = {</span></span>
<span class="line"><span style="color:#393a34;">    foo: &quot;bar&quot;,</span></span>
<span class="line"><span style="color:#393a34;">    func: function() {</span></span>
<span class="line"><span style="color:#393a34;">        var self = this;</span></span>
<span class="line"><span style="color:#393a34;">        console.log(this.foo);  </span></span>
<span class="line"><span style="color:#393a34;">        console.log(self.foo);  </span></span>
<span class="line"><span style="color:#393a34;">        (function() {</span></span>
<span class="line"><span style="color:#393a34;">            console.log(this.foo);  </span></span>
<span class="line"><span style="color:#393a34;">            console.log(self.foo);  </span></span>
<span class="line"><span style="color:#393a34;">        }());</span></span>
<span class="line"><span style="color:#393a34;">    }</span></span>
<span class="line"><span style="color:#393a34;">};</span></span>
<span class="line"><span style="color:#393a34;">myObject.func();</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>输出结果：bar bar undefined bar</p><p><strong>解析：</strong></p><ol><li>首先func是由myObject调用的，this指向myObject。又因为var self = this;所以self指向myObject。</li><li>这个立即执行匿名函数表达式是由window调用的，this指向window 。立即执行匿名函数的作用域处于myObject.func的作用域中，在这个作用域找不到self变量，沿着作用域链向上查找self变量，找到了指向 myObject对象的self。</li></ol><h3 id="_8-代码输出问题" tabindex="-1">8. 代码输出问题 <a class="header-anchor" href="#_8-代码输出问题" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">window.number = 2;</span></span>
<span class="line"><span style="color:#393a34;">var obj = {</span></span>
<span class="line"><span style="color:#393a34;"> number: 3,</span></span>
<span class="line"><span style="color:#393a34;"> db1: (function(){</span></span>
<span class="line"><span style="color:#393a34;">   console.log(this);</span></span>
<span class="line"><span style="color:#393a34;">   this.number *= 4;</span></span>
<span class="line"><span style="color:#393a34;">   return function(){</span></span>
<span class="line"><span style="color:#393a34;">     console.log(this);</span></span>
<span class="line"><span style="color:#393a34;">     this.number *= 5;</span></span>
<span class="line"><span style="color:#393a34;">   }</span></span>
<span class="line"><span style="color:#393a34;"> })()</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;">var db1 = obj.db1;</span></span>
<span class="line"><span style="color:#393a34;">db1();</span></span>
<span class="line"><span style="color:#393a34;">obj.db1();</span></span>
<span class="line"><span style="color:#393a34;">console.log(obj.number);     // 15</span></span>
<span class="line"><span style="color:#393a34;">console.log(window.number);  // 40</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>这道题目看清起来有点乱，但是实际上是考察this指向的:</p><ol><li>执行db1()时，this指向全局作用域，所以window.number * 4 = 8，然后执行匿名函数， 所以window.number * 5 = 40；</li><li>执行obj.db1();时，this指向obj对象，执行匿名函数，所以obj.numer * 5 = 15。</li></ol><h3 id="_9-代码输出结果-1" tabindex="-1">9. 代码输出结果 <a class="header-anchor" href="#_9-代码输出结果-1" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">var length = 10;</span></span>
<span class="line"><span style="color:#393a34;">function fn() {</span></span>
<span class="line"><span style="color:#393a34;">    console.log(this.length);</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;"> </span></span>
<span class="line"><span style="color:#393a34;">var obj = {</span></span>
<span class="line"><span style="color:#393a34;">  length: 5,</span></span>
<span class="line"><span style="color:#393a34;">  method: function(fn) {</span></span>
<span class="line"><span style="color:#393a34;">    fn();</span></span>
<span class="line"><span style="color:#393a34;">    arguments[0]();</span></span>
<span class="line"><span style="color:#393a34;">  }</span></span>
<span class="line"><span style="color:#393a34;">};</span></span>
<span class="line"><span style="color:#393a34;"> </span></span>
<span class="line"><span style="color:#393a34;">obj.method(fn, 1);</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>输出结果： 10 2</p><p><strong>解析：</strong></p><ol><li>第一次执行fn()，this指向window对象，输出10。</li><li>第二次执行<code>arguments[0]()</code>，相当于arguments调用方法，this指向arguments，而这里传了两个参数，故输出arguments长度为2。</li></ol><h3 id="_10-代码输出结果-1" tabindex="-1">10. 代码输出结果 <a class="header-anchor" href="#_10-代码输出结果-1" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">var a = 1;</span></span>
<span class="line"><span style="color:#393a34;">function printA(){</span></span>
<span class="line"><span style="color:#393a34;">  console.log(this.a);</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;">var obj={</span></span>
<span class="line"><span style="color:#393a34;">  a:2,</span></span>
<span class="line"><span style="color:#393a34;">  foo:printA,</span></span>
<span class="line"><span style="color:#393a34;">  bar:function(){</span></span>
<span class="line"><span style="color:#393a34;">    printA();</span></span>
<span class="line"><span style="color:#393a34;">  }</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">obj.foo(); // 2</span></span>
<span class="line"><span style="color:#393a34;">obj.bar(); // 1</span></span>
<span class="line"><span style="color:#393a34;">var foo = obj.foo;</span></span>
<span class="line"><span style="color:#393a34;">foo(); // 1</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>输出结果： 2 1 1</p><p><strong>解析：</strong></p><ol><li>obj.foo()，foo 的this指向obj对象，所以a会输出2；</li><li>obj.bar()，printA在bar方法中执行，所以此时printA的this指向的是window，所以会输出1；</li><li>foo()，foo是在全局对象中执行的，所以其this指向的是window，所以会输出1；</li></ol><h3 id="_11-代码输出结果-1" tabindex="-1">11. 代码输出结果 <a class="header-anchor" href="#_11-代码输出结果-1" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">var x = 3;</span></span>
<span class="line"><span style="color:#393a34;">var y = 4;</span></span>
<span class="line"><span style="color:#393a34;">var obj = {</span></span>
<span class="line"><span style="color:#393a34;">    x: 1,</span></span>
<span class="line"><span style="color:#393a34;">    y: 6,</span></span>
<span class="line"><span style="color:#393a34;">    getX: function() {</span></span>
<span class="line"><span style="color:#393a34;">        var x = 5;</span></span>
<span class="line"><span style="color:#393a34;">        return function() {</span></span>
<span class="line"><span style="color:#393a34;">            return this.x;</span></span>
<span class="line"><span style="color:#393a34;">        }();</span></span>
<span class="line"><span style="color:#393a34;">    },</span></span>
<span class="line"><span style="color:#393a34;">    getY: function() {</span></span>
<span class="line"><span style="color:#393a34;">        var y = 7;</span></span>
<span class="line"><span style="color:#393a34;">        return this.y;</span></span>
<span class="line"><span style="color:#393a34;">    }</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;">console.log(obj.getX()) // 3</span></span>
<span class="line"><span style="color:#393a34;">console.log(obj.getY()) // 6</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>输出结果：3 6</p><p><strong>解析：</strong></p><ol><li>我们知道，匿名函数的this是指向全局对象的，所以this指向window，会打印出3；</li><li>getY是由obj调用的，所以其this指向的是obj对象，会打印出6。</li></ol><h3 id="_12-代码输出结果-1" tabindex="-1">12. 代码输出结果 <a class="header-anchor" href="#_12-代码输出结果-1" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;"> var a = 10; </span></span>
<span class="line"><span style="color:#393a34;"> var obt = { </span></span>
<span class="line"><span style="color:#393a34;">   a: 20, </span></span>
<span class="line"><span style="color:#393a34;">   fn: function(){ </span></span>
<span class="line"><span style="color:#393a34;">     var a = 30; </span></span>
<span class="line"><span style="color:#393a34;">     console.log(this.a)</span></span>
<span class="line"><span style="color:#393a34;">   } </span></span>
<span class="line"><span style="color:#393a34;"> }</span></span>
<span class="line"><span style="color:#393a34;"> obt.fn();  // 20</span></span>
<span class="line"><span style="color:#393a34;"> obt.fn.call(); // 10</span></span>
<span class="line"><span style="color:#393a34;"> (obt.fn)(); // 20</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>输出结果： 20 10 20</p><p><strong>解析：</strong></p><ol><li>obt.fn()，fn是由obt调用的，所以其this指向obt对象，会打印出20；</li><li>obt.fn.call()，这里call的参数啥都没写，就表示null，我们知道如果call的参数为undefined或null，那么this就会指向全局对象this，所以会打印出 10；</li><li>(obt.fn)()， 这里给表达式加了括号，而括号的作用是改变表达式的运算顺序，而在这里加与不加括号并无影响；相当于 obt.fn()，所以会打印出 20；</li></ol><h3 id="_13-代码输出结果-1" tabindex="-1">13. 代码输出结果 <a class="header-anchor" href="#_13-代码输出结果-1" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">function a(xx){</span></span>
<span class="line"><span style="color:#393a34;">  this.x = xx;</span></span>
<span class="line"><span style="color:#393a34;">  return this</span></span>
<span class="line"><span style="color:#393a34;">};</span></span>
<span class="line"><span style="color:#393a34;">var x = a(5);</span></span>
<span class="line"><span style="color:#393a34;">var y = a(6);</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">console.log(x.x)  // undefined</span></span>
<span class="line"><span style="color:#393a34;">console.log(y.x)  // 6</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>输出结果： undefined 6</p><p><strong>解析：</strong></p><ol><li>最关键的就是var x = a(5)，函数a是在全局作用域调用，所以函数内部的this指向window对象。**所以 this.x = 5 就相当于：window.x = 5。**之后 return this，也就是说 var x = a(5) 中的x变量的值是window，这里的x将函数内部的x的值覆盖了。然后执行console.log(x.x)， 也就是console.log(window.x)，而window对象中没有x属性，所以会输出undefined。</li><li>当指向y.x时，会给全局变量中的x赋值为6，所以会打印出6。</li></ol><h3 id="_14-代码输出结果-1" tabindex="-1">14. 代码输出结果 <a class="header-anchor" href="#_14-代码输出结果-1" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">function foo(something){</span></span>
<span class="line"><span style="color:#393a34;">    this.a = something</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">var obj1 = {</span></span>
<span class="line"><span style="color:#393a34;">    foo: foo</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">var obj2 = {}</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">obj1.foo(2); </span></span>
<span class="line"><span style="color:#393a34;">console.log(obj1.a); // 2</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">obj1.foo.call(obj2, 3);</span></span>
<span class="line"><span style="color:#393a34;">console.log(obj2.a); // 3</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">var bar = new obj1.foo(4)</span></span>
<span class="line"><span style="color:#393a34;">console.log(obj1.a); // 2</span></span>
<span class="line"><span style="color:#393a34;">console.log(bar.a); // 4</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>输出结果： 2 3 2 4</p><p><strong>解析：</strong></p><ol><li>首先执行obj1.foo(2); 会在obj中添加a属性，其值为2。之后执行obj1.a，a是右obj1调用的，所以this指向obj，打印出2；</li><li>执行 obj1.foo.call(obj2, 3) 时，会将foo的this指向obj2，后面就和上面一样了，所以会打印出3；</li><li>obj1.a会打印出2；</li><li>最后就是考察this绑定的优先级了，new 绑定是比隐式绑定优先级高，所以会输出4。</li></ol><h3 id="_15-代码输出结果-1" tabindex="-1">15. 代码输出结果 <a class="header-anchor" href="#_15-代码输出结果-1" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">function foo(something){</span></span>
<span class="line"><span style="color:#393a34;">    this.a = something</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">var obj1 = {}</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">var bar = foo.bind(obj1);</span></span>
<span class="line"><span style="color:#393a34;">bar(2);</span></span>
<span class="line"><span style="color:#393a34;">console.log(obj1.a); // 2</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">var baz = new bar(3);</span></span>
<span class="line"><span style="color:#393a34;">console.log(obj1.a); // 2</span></span>
<span class="line"><span style="color:#393a34;">console.log(baz.a); // 3</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>输出结果： 2 2 3</p><p>这道题目和上面题目差不多，主要都是考察this绑定的优先级。记住以下结论即可：**this绑定的优先级：**<strong>new绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定。</strong></p><h2 id="三、作用域-变量提升-闭包" tabindex="-1">三、作用域&amp;变量提升&amp;闭包 <a class="header-anchor" href="#三、作用域-变量提升-闭包" aria-hidden="true">#</a></h2><h3 id="_1-代码输出结果-2" tabindex="-1">1. 代码输出结果 <a class="header-anchor" href="#_1-代码输出结果-2" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">(function(){</span></span>
<span class="line"><span style="color:#393a34;">   var x = y = 1;</span></span>
<span class="line"><span style="color:#393a34;">})();</span></span>
<span class="line"><span style="color:#393a34;">var z;</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">console.log(y); // 1</span></span>
<span class="line"><span style="color:#393a34;">console.log(z); // undefined</span></span>
<span class="line"><span style="color:#393a34;">console.log(x); // Uncaught ReferenceError: x is not defined</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>这段代码的关键在于：var x = y = 1; 实际上这里是从右往左执行的，首先执行y = 1, 因为y没有使用var声明，所以它是一个全局变量，然后第二步是将y赋值给x，讲一个全局变量赋值给了一个局部变量，最终，x是一个局部变量，y是一个全局变量，所以打印x是报错。</p><h3 id="_2-代码输出结果-2" tabindex="-1">2. 代码输出结果 <a class="header-anchor" href="#_2-代码输出结果-2" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">var a, b</span></span>
<span class="line"><span style="color:#393a34;">(function () {</span></span>
<span class="line"><span style="color:#393a34;">   console.log(a);</span></span>
<span class="line"><span style="color:#393a34;">   console.log(b);</span></span>
<span class="line"><span style="color:#393a34;">   var a = (b = 3);</span></span>
<span class="line"><span style="color:#393a34;">   console.log(a);</span></span>
<span class="line"><span style="color:#393a34;">   console.log(b);   </span></span>
<span class="line"><span style="color:#393a34;">})()</span></span>
<span class="line"><span style="color:#393a34;">console.log(a);</span></span>
<span class="line"><span style="color:#393a34;">console.log(b);</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>输出结果：</p><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">undefined </span></span>
<span class="line"><span style="color:#393a34;">undefined </span></span>
<span class="line"><span style="color:#393a34;">3 </span></span>
<span class="line"><span style="color:#393a34;">3 </span></span>
<span class="line"><span style="color:#393a34;">undefined </span></span>
<span class="line"><span style="color:#393a34;">3</span></span>
<span class="line"><span style="color:#393a34;">undefined </span></span>
<span class="line"><span style="color:#393a34;">undefined </span></span>
<span class="line"><span style="color:#393a34;">3 </span></span>
<span class="line"><span style="color:#393a34;">3 </span></span>
<span class="line"><span style="color:#393a34;">undefined </span></span>
<span class="line"><span style="color:#393a34;">3</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>这个题目和上面题目考察的知识点类似，b赋值为3，b此时是一个全局变量，而将3赋值给a，a是一个局部变量，所以最后打印的时候，a仍旧是undefined。</p><h3 id="_3-代码输出结果-2" tabindex="-1">3. 代码输出结果 <a class="header-anchor" href="#_3-代码输出结果-2" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">var friendName = &#39;World&#39;;</span></span>
<span class="line"><span style="color:#393a34;">(function() {</span></span>
<span class="line"><span style="color:#393a34;">  if (typeof friendName === &#39;undefined&#39;) {</span></span>
<span class="line"><span style="color:#393a34;">    var friendName = &#39;Jack&#39;;</span></span>
<span class="line"><span style="color:#393a34;">    console.log(&#39;Goodbye &#39; + friendName);</span></span>
<span class="line"><span style="color:#393a34;">  } else {</span></span>
<span class="line"><span style="color:#393a34;">    console.log(&#39;Hello &#39; + friendName);</span></span>
<span class="line"><span style="color:#393a34;">  }</span></span>
<span class="line"><span style="color:#393a34;">})();</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>输出结果：Goodbye Jack</p><p>我们知道，在 JavaScript中， Function 和 var 都会被提升（变量提升），所以上面的代码就相当于：</p><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">var name = &#39;World!&#39;;</span></span>
<span class="line"><span style="color:#393a34;">(function () {</span></span>
<span class="line"><span style="color:#393a34;">    var name;</span></span>
<span class="line"><span style="color:#393a34;">    if (typeof name === &#39;undefined&#39;) {</span></span>
<span class="line"><span style="color:#393a34;">        name = &#39;Jack&#39;;</span></span>
<span class="line"><span style="color:#393a34;">        console.log(&#39;Goodbye &#39; + name);</span></span>
<span class="line"><span style="color:#393a34;">    } else {</span></span>
<span class="line"><span style="color:#393a34;">        console.log(&#39;Hello &#39; + name);</span></span>
<span class="line"><span style="color:#393a34;">    }</span></span>
<span class="line"><span style="color:#393a34;">})();</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>这样，答案就一目了然了。</p><h3 id="_4-代码输出结果-2" tabindex="-1">4. 代码输出结果 <a class="header-anchor" href="#_4-代码输出结果-2" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">function fn1(){</span></span>
<span class="line"><span style="color:#393a34;">  console.log(&#39;fn1&#39;)</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;">var fn2</span></span>
<span class="line"><span style="color:#393a34;"> </span></span>
<span class="line"><span style="color:#393a34;">fn1()</span></span>
<span class="line"><span style="color:#393a34;">fn2()</span></span>
<span class="line"><span style="color:#393a34;"> </span></span>
<span class="line"><span style="color:#393a34;">fn2 = function() {</span></span>
<span class="line"><span style="color:#393a34;">  console.log(&#39;fn2&#39;)</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;"> </span></span>
<span class="line"><span style="color:#393a34;">fn2()</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>输出结果：</p><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">fn1</span></span>
<span class="line"><span style="color:#393a34;">Uncaught TypeError: fn2 is not a function</span></span>
<span class="line"><span style="color:#393a34;">fn2</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这里也是在考察变量提升，关键在于第一个fn2()，这时fn2仍是一个undefined的变量，所以会报错fn2不是一个函数。</p><h3 id="_5-代码输出结果-1" tabindex="-1">5. 代码输出结果 <a class="header-anchor" href="#_5-代码输出结果-1" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">function a() {</span></span>
<span class="line"><span style="color:#393a34;">    var temp = 10;</span></span>
<span class="line"><span style="color:#393a34;">    function b() {</span></span>
<span class="line"><span style="color:#393a34;">        console.log(temp); // 10</span></span>
<span class="line"><span style="color:#393a34;">    }</span></span>
<span class="line"><span style="color:#393a34;">    b();</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;">a();</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">function a() {</span></span>
<span class="line"><span style="color:#393a34;">    var temp = 10;</span></span>
<span class="line"><span style="color:#393a34;">    b();</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;">function b() {</span></span>
<span class="line"><span style="color:#393a34;">    console.log(temp); // 报错 Uncaught ReferenceError: temp is not defined</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;">a();</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>在上面的两段代码中，第一段是可以正常输出，这个应该没啥问题，关键在于第二段代码，它会报错Uncaught ReferenceError: temp is not defined。这时因为在b方法执行时，temp 的值为undefined。</p><h3 id="_6-代码输出结果-2" tabindex="-1">6. 代码输出结果 <a class="header-anchor" href="#_6-代码输出结果-2" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;"> var a=3;</span></span>
<span class="line"><span style="color:#393a34;"> function c(){</span></span>
<span class="line"><span style="color:#393a34;">    alert(a);</span></span>
<span class="line"><span style="color:#393a34;"> }</span></span>
<span class="line"><span style="color:#393a34;"> (function(){</span></span>
<span class="line"><span style="color:#393a34;">  var a=4;</span></span>
<span class="line"><span style="color:#393a34;">  c();</span></span>
<span class="line"><span style="color:#393a34;"> })();</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>js中变量的作用域链与定义时的环境有关，与执行时无关。执行环境只会改变this、传递的参数、全局变量等</p><h3 id="_7-代码输出问题" tabindex="-1">7. 代码输出问题 <a class="header-anchor" href="#_7-代码输出问题" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">function fun(n, o) {</span></span>
<span class="line"><span style="color:#393a34;">  console.log(o)</span></span>
<span class="line"><span style="color:#393a34;">  return {</span></span>
<span class="line"><span style="color:#393a34;">    fun: function(m){</span></span>
<span class="line"><span style="color:#393a34;">      return fun(m, n);</span></span>
<span class="line"><span style="color:#393a34;">    }</span></span>
<span class="line"><span style="color:#393a34;">  };</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;">var a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);</span></span>
<span class="line"><span style="color:#393a34;">var b = fun(0).fun(1).fun(2).fun(3);</span></span>
<span class="line"><span style="color:#393a34;">var c = fun(0).fun(1);  c.fun(2);  c.fun(3);</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>输出结果：</p><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">undefined  0  0  0</span></span>
<span class="line"><span style="color:#393a34;">undefined  0  1  2</span></span>
<span class="line"><span style="color:#393a34;">undefined  0  1  1</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这是一道关于闭包的题目，对于fun方法，调用之后返回的是一个对象。我们知道，当调用函数的时候传入的实参比函数声明时指定的形参个数要少，剩下的形参都将设置为undefined值。所以 <code>console.log(o);</code> 会输出undefined。而a就是是fun(0)返回的那个对象。也就是说，函数fun中参数 n 的值是0，而返回的那个对象中，需要一个参数n，而这个对象的作用域中没有n，它就继续沿着作用域向上一级的作用域中寻找n，最后在函数fun中找到了n，n的值是0。了解了这一点，其他运算就很简单了，以此类推。</p><h3 id="_8-代码输出结果-1" tabindex="-1">8. 代码输出结果 <a class="header-anchor" href="#_8-代码输出结果-1" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">f = function() {return true;};   </span></span>
<span class="line"><span style="color:#393a34;">g = function() {return false;};   </span></span>
<span class="line"><span style="color:#393a34;">(function() {   </span></span>
<span class="line"><span style="color:#393a34;">   if (g() &amp;&amp; [] == ![]) {   </span></span>
<span class="line"><span style="color:#393a34;">      f = function f() {return false;};   </span></span>
<span class="line"><span style="color:#393a34;">      function g() {return true;}   </span></span>
<span class="line"><span style="color:#393a34;">   }   </span></span>
<span class="line"><span style="color:#393a34;">})();   </span></span>
<span class="line"><span style="color:#393a34;">console.log(f());</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>输出结果： false</p><p>这里首先定义了两个变量f和g，我们知道变量是可以重新赋值的。后面是一个匿名自执行函数，在 if 条件中调用了函数 g()，由于在匿名函数中，又重新定义了函数g，就覆盖了外部定义的变量g，所以，这里调用的是内部函数 g 方法，返回为 true。第一个条件通过，进入第二个条件。</p><p>第二个条件是[] == ![]，先看 ![] ，在 JavaScript 中，当用于布尔运算时，比如在这里，对象的非空引用被视为 true，空引用 null 则被视为 false。由于这里不是一个 null, 而是一个没有元素的数组，所以 [] 被视为 true, 而 ![] 的结果就是 false 了。当一个布尔值参与到条件运算的时候，true 会被看作 1, 而 false 会被看作 0。现在条件变成了 [] == 0 的问题了，当一个对象参与条件比较的时候，它会被求值，求值的结果是数组成为一个字符串，[] 的结果就是 &#39;&#39; ，而 &#39;&#39; 会被当作 0 ，所以，条件成立。</p><p>两个条件都成立，所以会执行条件中的代码， f 在定义是没有使用var，所以他是一个全局变量。因此，这里会通过闭包访问到外部的变量 f, 重新赋值，现在执行 f 函数返回值已经成为 false 了。而 g 则不会有这个问题，这里是一个函数内定义的 g，不会影响到外部的 g 函数。所以最后的结果就是 false。</p><h2 id="四、原型-继承" tabindex="-1">四、原型&amp;继承 <a class="header-anchor" href="#四、原型-继承" aria-hidden="true">#</a></h2><h3 id="_1-代码输出结果-3" tabindex="-1">1. 代码输出结果 <a class="header-anchor" href="#_1-代码输出结果-3" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">function Person(name) {</span></span>
<span class="line"><span style="color:#393a34;">    this.name = name</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;">var p2 = new Person(&#39;king&#39;);</span></span>
<span class="line"><span style="color:#393a34;">console.log(p2.__proto__) //Person.prototype</span></span>
<span class="line"><span style="color:#393a34;">console.log(p2.__proto__.__proto__) //Object.prototype</span></span>
<span class="line"><span style="color:#393a34;">console.log(p2.__proto__.__proto__.__proto__) // null</span></span>
<span class="line"><span style="color:#393a34;">console.log(p2.__proto__.__proto__.__proto__.__proto__)//null后面没有了，报错</span></span>
<span class="line"><span style="color:#393a34;">console.log(p2.__proto__.__proto__.__proto__.__proto__.__proto__)//null后面没有了，报错</span></span>
<span class="line"><span style="color:#393a34;">console.log(p2.constructor)//Person</span></span>
<span class="line"><span style="color:#393a34;">console.log(p2.prototype)//undefined p2是实例，没有prototype属性</span></span>
<span class="line"><span style="color:#393a34;">console.log(Person.constructor)//Function 一个空函数</span></span>
<span class="line"><span style="color:#393a34;">console.log(Person.prototype)//打印出Person.prototype这个对象里所有的方法和属性</span></span>
<span class="line"><span style="color:#393a34;">console.log(Person.prototype.constructor)//Person</span></span>
<span class="line"><span style="color:#393a34;">console.log(Person.prototype.__proto__)// Object.prototype</span></span>
<span class="line"><span style="color:#393a34;">console.log(Person.__proto__) //Function.prototype</span></span>
<span class="line"><span style="color:#393a34;">console.log(Function.prototype.__proto__)//Object.prototype</span></span>
<span class="line"><span style="color:#393a34;">console.log(Function.__proto__)//Function.prototype</span></span>
<span class="line"><span style="color:#393a34;">console.log(Object.__proto__)//Function.prototype</span></span>
<span class="line"><span style="color:#393a34;">console.log(Object.prototype.__proto__)//null</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>这道义题目考察原型、原型链的基础，记住就可以了。</p><h3 id="_2-代码输出结果-3" tabindex="-1">2. 代码输出结果 <a class="header-anchor" href="#_2-代码输出结果-3" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">// a</span></span>
<span class="line"><span style="color:#393a34;">function Foo () {</span></span>
<span class="line"><span style="color:#393a34;"> getName = function () {</span></span>
<span class="line"><span style="color:#393a34;">   console.log(1);</span></span>
<span class="line"><span style="color:#393a34;"> }</span></span>
<span class="line"><span style="color:#393a34;"> return this;</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;">// b</span></span>
<span class="line"><span style="color:#393a34;">Foo.getName = function () {</span></span>
<span class="line"><span style="color:#393a34;"> console.log(2);</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;">// c</span></span>
<span class="line"><span style="color:#393a34;">Foo.prototype.getName = function () {</span></span>
<span class="line"><span style="color:#393a34;"> console.log(3);</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;">// d</span></span>
<span class="line"><span style="color:#393a34;">var getName = function () {</span></span>
<span class="line"><span style="color:#393a34;"> console.log(4);</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;">// e</span></span>
<span class="line"><span style="color:#393a34;">function getName () {</span></span>
<span class="line"><span style="color:#393a34;"> console.log(5);</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">Foo.getName();           // 2</span></span>
<span class="line"><span style="color:#393a34;">getName();               // 4</span></span>
<span class="line"><span style="color:#393a34;">Foo().getName();         // 1</span></span>
<span class="line"><span style="color:#393a34;">getName();               // 1 </span></span>
<span class="line"><span style="color:#393a34;">new Foo.getName();       // 2</span></span>
<span class="line"><span style="color:#393a34;">new Foo().getName();     // 3</span></span>
<span class="line"><span style="color:#393a34;">new new Foo().getName(); // 3</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><p>输出结果：2 4 1 1 2 3 3</p><p><strong>解析：</strong></p><ol><li>**Foo.getName()，**Foo为一个函数对象，对象都可以有属性，b 处定义Foo的getName属性为函数，输出2；</li><li>**getName()，**这里看d、e处，d为函数表达式，e为函数声明，两者区别在于变量提升，函数声明的 5 会被后边函数表达式的 4 覆盖；</li><li>**Foo().getName()，**这里要看a处，在Foo内部将全局的getName重新赋值为 console.log(1) 的函数，执行Foo()返回 this，这个this指向window，Foo().getName() 即为window.getName()，输出 1；</li><li>**getName()，**上面3中，全局的getName已经被重新赋值，所以这里依然输出 1；</li><li>**new Foo.getName()，**这里等价于 new (Foo.getName())，先执行 Foo.getName()，输出 2，然后new一个实例；</li><li>**new Foo().getName()，**这里等价于 (new Foo()).getName(), 先new一个Foo的实例，再执行这个实例的getName方法，但是这个实例本身没有这个方法，所以去原型链__protot__上边找，实例.<strong>protot</strong> === Foo.prototype，所以输出 3；</li><li>**new new Foo().getName()，**这里等价于new (new Foo().getName())，如上述6，先输出 3，然后new 一个 new Foo().getName() 的实例。</li></ol><h3 id="_3-代码输出结果-3" tabindex="-1">3. 代码输出结果 <a class="header-anchor" href="#_3-代码输出结果-3" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">var F = function() {};</span></span>
<span class="line"><span style="color:#393a34;">Object.prototype.a = function() {</span></span>
<span class="line"><span style="color:#393a34;">  console.log(&#39;a&#39;);</span></span>
<span class="line"><span style="color:#393a34;">};</span></span>
<span class="line"><span style="color:#393a34;">Function.prototype.b = function() {</span></span>
<span class="line"><span style="color:#393a34;">  console.log(&#39;b&#39;);</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;">var f = new F();</span></span>
<span class="line"><span style="color:#393a34;">f.a();</span></span>
<span class="line"><span style="color:#393a34;">f.b();</span></span>
<span class="line"><span style="color:#393a34;">F.a();</span></span>
<span class="line"><span style="color:#393a34;">F.b()</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>输出结果：</p><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">a</span></span>
<span class="line"><span style="color:#393a34;">Uncaught TypeError: f.b is not a function</span></span>
<span class="line"><span style="color:#393a34;">a</span></span>
<span class="line"><span style="color:#393a34;">b</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>解析：</strong></p><ol><li>f 并不是 Function 的实例，因为它本来就不是构造函数，调用的是 Function 原型链上的相关属性和方法，只能访问到 Object 原型链。所以 f.a() 输出 a ，而 f.b() 就报错了。</li><li>F 是个构造函数，而 F 是构造函数 Function 的一个实例。因为 F instanceof Object === true，F instanceof Function === true，由此可以得出结论：F 是 Object 和 Function 两个的实例，即 F 能访问到 a， 也能访问到 b。所以 F.a() 输出 a ，F.b() 输出 b。</li></ol><h3 id="_4-代码输出结果-3" tabindex="-1">4. 代码输出结果 <a class="header-anchor" href="#_4-代码输出结果-3" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">function Foo(){</span></span>
<span class="line"><span style="color:#393a34;">    Foo.a = function(){</span></span>
<span class="line"><span style="color:#393a34;">        console.log(1);</span></span>
<span class="line"><span style="color:#393a34;">    }</span></span>
<span class="line"><span style="color:#393a34;">    this.a = function(){</span></span>
<span class="line"><span style="color:#393a34;">        console.log(2)</span></span>
<span class="line"><span style="color:#393a34;">    }</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">Foo.prototype.a = function(){</span></span>
<span class="line"><span style="color:#393a34;">    console.log(3);</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">Foo.a = function(){</span></span>
<span class="line"><span style="color:#393a34;">    console.log(4);</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">Foo.a();</span></span>
<span class="line"><span style="color:#393a34;">let obj = new Foo();</span></span>
<span class="line"><span style="color:#393a34;">obj.a();</span></span>
<span class="line"><span style="color:#393a34;">Foo.a();</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>输出结果：4 2 1</p><p><strong>解析：</strong></p><ol><li>Foo.a() 这个是调用 Foo 函数的静态方法 a，虽然 Foo 中有优先级更高的属性方法 a，但 Foo 此时没有被调用，所以此时输出 Foo 的静态方法 a 的结果：4</li><li>let obj = new Foo(); 使用了 new 方法调用了函数，返回了函数实例对象，此时 Foo 函数内部的属性方法初始化，原型链建立。</li><li>obj.a() ; 调用 obj 实例上的方法 a，该实例上目前有两个 a 方法：一个是内部属性方法，另一个是原型上的方法。当这两者都存在时，首先查找 ownProperty ，如果没有才去原型链上找，所以调用实例上的 a 输出：2</li><li>Foo.a() ; 根据第2步可知 Foo 函数内部的属性方法已初始化，覆盖了同名的静态方法，所以输出：1</li></ol><h3 id="_5-代码输出结果-2" tabindex="-1">5. 代码输出结果 <a class="header-anchor" href="#_5-代码输出结果-2" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">function Dog() {</span></span>
<span class="line"><span style="color:#393a34;">  this.name = &#39;puppy&#39;</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;">Dog.prototype.bark = () =&gt; {</span></span>
<span class="line"><span style="color:#393a34;">  console.log(&#39;woof!woof!&#39;)</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;">const dog = new Dog()</span></span>
<span class="line"><span style="color:#393a34;">console.log(Dog.prototype.constructor === Dog &amp;&amp; dog.constructor === Dog &amp;&amp; dog instanceof Dog)</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>输出结果：true</p><p><strong>解析：</strong></p><p>因为constructor是prototype上的属性，所以dog.constructor实际上就是指向Dog.prototype.constructor；constructor属性指向构造函数。instanceof而实际检测的是类型是否在实例的原型链上。</p><p>constructor是prototype上的属性，这一点很容易被忽略掉。constructor和instanceof 的作用是不同的，感性地来说，constructor的限制比较严格，它只能严格对比对象的构造函数是不是指定的值；而instanceof比较松散，只要检测的类型在原型链上，就会返回true。</p><h3 id="_6-代码输出结果-3" tabindex="-1">6. 代码输出结果 <a class="header-anchor" href="#_6-代码输出结果-3" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">var A = {n: 4399};</span></span>
<span class="line"><span style="color:#393a34;">var B =  function(){this.n = 9999};</span></span>
<span class="line"><span style="color:#393a34;">var C =  function(){var n = 8888};</span></span>
<span class="line"><span style="color:#393a34;">B.prototype = A;</span></span>
<span class="line"><span style="color:#393a34;">C.prototype = A;</span></span>
<span class="line"><span style="color:#393a34;">var b = new B();</span></span>
<span class="line"><span style="color:#393a34;">var c = new C();</span></span>
<span class="line"><span style="color:#393a34;">A.n++</span></span>
<span class="line"><span style="color:#393a34;">console.log(b.n);</span></span>
<span class="line"><span style="color:#393a34;">console.log(c.n);</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>输出结果：9999 4400</p><p><strong>解析：</strong></p><ol><li>console.log(b.n)，在查找b.n是首先查找 b 对象自身有没有 n 属性，如果没有会去原型（prototype）上查找，当执行var b = new B()时，函数内部this.n=9999(此时this指向 b) 返回b对象，b对象有自身的n属性，所以返回 9999。</li><li>console.log(c.n)，同理，当执行var c = new C()时，c对象没有自身的n属性，向上查找，找到原型 （prototype）上的 n 属性，因为 A.n++(此时对象A中的n为4400)， 所以返回4400。</li></ol><h3 id="_7-代码输出问题-1" tabindex="-1">7. 代码输出问题 <a class="header-anchor" href="#_7-代码输出问题-1" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">function A(){</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;">function B(a){</span></span>
<span class="line"><span style="color:#393a34;">　　this.a = a;</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;">function C(a){</span></span>
<span class="line"><span style="color:#393a34;">　　if(a){</span></span>
<span class="line"><span style="color:#393a34;">this.a = a;</span></span>
<span class="line"><span style="color:#393a34;">　　}</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;">A.prototype.a = 1;</span></span>
<span class="line"><span style="color:#393a34;">B.prototype.a = 1;</span></span>
<span class="line"><span style="color:#393a34;">C.prototype.a = 1;</span></span>
<span class="line"><span style="color:#393a34;"> </span></span>
<span class="line"><span style="color:#393a34;">console.log(new A().a);</span></span>
<span class="line"><span style="color:#393a34;">console.log(new B().a);</span></span>
<span class="line"><span style="color:#393a34;">console.log(new C(2).a);</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>输出结果：1 undefined 2</p><p><strong>解析：</strong></p><ol><li>console.log(new A().a)，new A()为构造函数创建的对象，本身没有a属性，所以向它的原型去找，发现原型的a属性的属性值为1，故该输出值为1；</li><li>console.log(new B().a)，ew B()为构造函数创建的对象，该构造函数有参数a，但该对象没有传参，故该输出值为undefined;</li><li>console.log(new C(2).a)，new C()为构造函数创建的对象，该构造函数有参数a，且传的实参为2，执行函数内部，发现if为真，执行this.a = 2,故属性a的值为2。</li></ol><h3 id="_8-代码输出问题-1" tabindex="-1">8 代码输出问题 <a class="header-anchor" href="#_8-代码输出问题-1" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">function Parent() {</span></span>
<span class="line"><span style="color:#393a34;">    this.a = 1;</span></span>
<span class="line"><span style="color:#393a34;">    this.b = [1, 2, this.a];</span></span>
<span class="line"><span style="color:#393a34;">    this.c = { demo: 5 };</span></span>
<span class="line"><span style="color:#393a34;">    this.show = function () {</span></span>
<span class="line"><span style="color:#393a34;">        console.log(this.a , this.b , this.c.demo );</span></span>
<span class="line"><span style="color:#393a34;">    }</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">function Child() {</span></span>
<span class="line"><span style="color:#393a34;">    this.a = 2;</span></span>
<span class="line"><span style="color:#393a34;">    this.change = function () {</span></span>
<span class="line"><span style="color:#393a34;">        this.b.push(this.a);</span></span>
<span class="line"><span style="color:#393a34;">        this.a = this.b.length;</span></span>
<span class="line"><span style="color:#393a34;">        this.c.demo = this.a++;</span></span>
<span class="line"><span style="color:#393a34;">    }</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">Child.prototype = new Parent();</span></span>
<span class="line"><span style="color:#393a34;">var parent = new Parent();</span></span>
<span class="line"><span style="color:#393a34;">var child1 = new Child();</span></span>
<span class="line"><span style="color:#393a34;">var child2 = new Child();</span></span>
<span class="line"><span style="color:#393a34;">child1.a = 11;</span></span>
<span class="line"><span style="color:#393a34;">child2.a = 12;</span></span>
<span class="line"><span style="color:#393a34;">parent.show();</span></span>
<span class="line"><span style="color:#393a34;">child1.show();</span></span>
<span class="line"><span style="color:#393a34;">child2.show();</span></span>
<span class="line"><span style="color:#393a34;">child1.change();</span></span>
<span class="line"><span style="color:#393a34;">child2.change();</span></span>
<span class="line"><span style="color:#393a34;">parent.show();</span></span>
<span class="line"><span style="color:#393a34;">child1.show();</span></span>
<span class="line"><span style="color:#393a34;">child2.show();</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><p>输出结果：</p><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">parent.show(); // 1  [1,2,1] 5</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">child1.show(); // 11 [1,2,1] 5</span></span>
<span class="line"><span style="color:#393a34;">child2.show(); // 12 [1,2,1] 5</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">parent.show(); // 1 [1,2,1] 5</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">child1.show(); // 5 [1,2,1,11,12] 5</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">child2.show(); // 6 [1,2,1,11,12] 5</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>这道题目值得神帝，他涉及到的知识点很多，例如<strong>this的指向、原型、原型链、类的继承、数据类型</strong>等。</p><p><strong>解析</strong>**：**</p><ol><li>parent.show()，可以直接获得所需的值，没啥好说的；</li><li>child1.show()，<code>Child</code>的构造函数原本是指向<code>Child</code>的，题目显式将<code>Child</code>类的原型对象指向了<code>Parent</code>类的一个实例，需要注意<code>Child.prototype</code>指向的是<code>Parent</code>的实例<code>parent</code>，而不是指向<code>Parent</code>这个类。</li><li>child2.show()，这个也没啥好说的；</li><li>parent.show()，<code>parent</code>是一个<code>Parent</code>类的实例，<code>Child.prorotype</code>指向的是<code>Parent</code>类的另一个实例，两者在堆内存中互不影响，所以上述操作不影响<code>parent</code>实例，所以输出结果不变；</li><li>child1.show()，<code>child1</code>执行了<code>change()</code>方法后，发生了怎样的变化呢?</li></ol><ul><li><strong>this.b.push(this.a)，<strong>由于this的动态指向特性，this.b会指向<code>Child.prototype</code>上的</strong>b</strong>数组,this.a会指向<code>child1</code>的<strong>a</strong>属性,所以<code>Child.prototype.b</code>变成了**[1,2,1,11]**;</li><li><strong>this.a = this.b.length，<strong>这条语句中<code>this.a</code>和<code>this.b</code>的指向与上一句一致，故结果为<code>child1.a</code>变为</strong>4</strong>;</li><li><strong>this.c.demo = this.a++，<strong>由于<code>child1</code>自身属性并没有</strong>c</strong>这个属性，所以此处的<code>this.c</code>会指向<code>Child.prototype.c</code>，<code>this.a</code>值为<strong>4</strong>，为原始类型，故赋值操作时会直接赋值，<code>Child.prototype.c.demo</code>的结果为<strong>4</strong>，而<code>this.a</code>随后自增为<strong>5(4 + 1 = 5)。</strong></li></ul><ol><li><code>child2</code>执行了<code>change()</code>方法, 而<code>child2</code>和<code>child1</code>均是<code>Child</code>类的实例，所以他们的原型链指向同一个原型对象<code>Child.prototype</code>,也就是同一个<code>parent</code>实例，所以<code>child2.change()</code>中所有影响到原型对象的语句都会影响<code>child1</code>的最终输出结果。</li></ol><ul><li><strong>this.b.push(this.a)，<strong>由于this的动态指向特性，this.b会指向<code>Child.prototype</code>上的</strong>b</strong>数组,this.a会指向<code>child2</code>的<strong>a</strong>属性,所以<code>Child.prototype.b</code>变成了**[1,2,1,11,12]**;</li><li><strong>this.a = this.b.length，<strong>这条语句中<code>this.a</code>和<code>this.b</code>的指向与上一句一致，故结果为<code>child2.a</code>变为</strong>5</strong>;</li><li><strong>this.c.demo = this.a++，<strong>由于<code>child2</code>自身属性并没有</strong>c</strong>这个属性，所以此处的<code>this.c</code>会指向<code>Child.prototype.c</code>，故执行结果为<code>Child.prototype.c.demo</code>的值变为<code>child2.a</code>的值<strong>5</strong>，而<code>child2.a</code>最终自增为<strong>6(5 + 1 = 6)。</strong></li></ul><h3 id="_9-代码输出结果-2" tabindex="-1">9. 代码输出结果 <a class="header-anchor" href="#_9-代码输出结果-2" aria-hidden="true">#</a></h3><div class="language- line-numbers-mode"><span class="copy"></span><pre><code><span class="line"><span style="color:#393a34;">function SuperType(){</span></span>
<span class="line"><span style="color:#393a34;">    this.property = true;</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">SuperType.prototype.getSuperValue = function(){</span></span>
<span class="line"><span style="color:#393a34;">    return this.property;</span></span>
<span class="line"><span style="color:#393a34;">};</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">function SubType(){</span></span>
<span class="line"><span style="color:#393a34;">    this.subproperty = false;</span></span>
<span class="line"><span style="color:#393a34;">}</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">SubType.prototype = new SuperType();</span></span>
<span class="line"><span style="color:#393a34;">SubType.prototype.getSubValue = function (){</span></span>
<span class="line"><span style="color:#393a34;">    return this.subproperty;</span></span>
<span class="line"><span style="color:#393a34;">};</span></span>
<span class="line"><span style="color:#393a34;"></span></span>
<span class="line"><span style="color:#393a34;">var instance = new SubType();</span></span>
<span class="line"><span style="color:#393a34;">console.log(instance.getSuperValue());</span></span>
<span class="line"><span style="color:#393a34;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>输出结果：true</p><p>实际上，这段代码就是在实现原型链继承，SubType继承了SuperType，本质是重写了SubType的原型对象，代之以一个新类型的实例。SubType的原型被重写了，所以instance.constructor指向的是SuperType。具体如下：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1500604/1620043144097-44798602-b916-406d-bc50-e003f27dece2.png" alt="image.png"></p></div></div></main><footer class="VPDocFooter" data-v-542b5b3a data-v-25535ebb><div class="edit-info" data-v-25535ebb><div class="edit-link" data-v-25535ebb><a class="VPLink link edit-link-button" href="https://github.com/cll123456/common-study/edit/master/docs/docs/面试/12-offer收割机之代码输出篇/12-offer收割机之代码输出篇.md" target="_blank" rel="noopener noreferrer" data-v-25535ebb data-v-0c96c854><!--[--><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="edit-link-icon" data-v-25535ebb><path d="M18,23H4c-1.7,0-3-1.3-3-3V6c0-1.7,1.3-3,3-3h7c0.6,0,1,0.4,1,1s-0.4,1-1,1H4C3.4,5,3,5.4,3,6v14c0,0.6,0.4,1,1,1h14c0.6,0,1-0.4,1-1v-7c0-0.6,0.4-1,1-1s1,0.4,1,1v7C21,21.7,19.7,23,18,23z"></path><path d="M8,17c-0.3,0-0.5-0.1-0.7-0.3C7,16.5,6.9,16.1,7,15.8l1-4c0-0.2,0.1-0.3,0.3-0.5l9.5-9.5c1.2-1.2,3.2-1.2,4.4,0c1.2,1.2,1.2,3.2,0,4.4l-9.5,9.5c-0.1,0.1-0.3,0.2-0.5,0.3l-4,1C8.2,17,8.1,17,8,17zM9.9,12.5l-0.5,2.1l2.1-0.5l9.3-9.3c0.4-0.4,0.4-1.1,0-1.6c-0.4-0.4-1.2-0.4-1.6,0l0,0L9.9,12.5z M18.5,2.5L18.5,2.5L18.5,2.5z"></path></svg> 前往GitHub编辑此页<!--]--><!----></a></div><div class="last-updated" data-v-25535ebb><p class="VPLastUpdated" data-v-25535ebb data-v-4e258763>上次更新: <time datatime="2022-08-06T14:24:44.000Z" data-v-4e258763></time></p></div></div><div class="prev-next" data-v-25535ebb><div class="pager" data-v-25535ebb><a class="pager-link prev" href="/common-study/%E9%9D%A2%E8%AF%95/11-offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%AF%87/11-offer%E6%94%B6%E5%89%B2%E6%9C%BA%E4%B9%8B%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%AF%87.html" data-v-25535ebb><span class="desc" data-v-25535ebb>Previous page</span><span class="title" data-v-25535ebb>11-offer收割机之手写代码篇</span></a></div><div class="has-prev pager" data-v-25535ebb><a class="pager-link next" href="/common-study/%E9%9D%A2%E8%AF%95/13-LeetCode%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83%E9%A2%98%E7%9B%AE/13-LeetCode%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83%E9%A2%98%E7%9B%AE.html" data-v-25535ebb><span class="desc" data-v-25535ebb>Next page</span><span class="title" data-v-25535ebb>13-LeetCode面试常考题目</span></a></div></div></footer><!--[--><!--]--></div></div></div></div></div><footer class="VPFooter has-sidebar" data-v-66204374 data-v-0772fb3f><div class="container" data-v-0772fb3f><p class="message" data-v-0772fb3f>Released under the MIT License.</p><p class="copyright" data-v-0772fb3f>Copyright © 2022-present Twinkle &amp; common-study Contributors</p></div></footer><!--[--><!--]--></div></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"index.md\":\"b3e57fb0\",\"packages-study_cac_cac.dialog.md\":\"f6f29568\",\"packages-study_cac_cac.md\":\"41a21ee5\",\"packages-study_cac_max-readme-temp.md\":\"2de53ef3\",\"packages-study_cac_package.md\":\"6c84f521\",\"vue3-analysis_1-learn-reactive_1-learn-reactive.md\":\"c1ed14f5\",\"vue3-analysis_10-finish-comp-props_10-finish-comp-props.md\":\"f66b0ef8\",\"vue3-analysis_11-finish-comp-slots_11-finish-comp-slots.md\":\"efc2705e\",\"vue3-analysis_12-finish-provide-inject_12-finish-provide-inject.md\":\"a4e2103c\",\"vue3-analysis_13-finish-custom-render_13-finish-custom-render.md\":\"cc200490\",\"vue3-analysis_14-finish-elem-update_14-finish-elem-update.md\":\"163eda59\",\"vue3-analysis_15-finish-diff_15-finish-diff.md\":\"8907d2fe\",\"vue3-analysis_16-finish-comp-update_16-finish-comp-update.md\":\"8e563123\",\"vue3-analysis_17-finish-nexttick_17-finish-nexttick.md\":\"da512398\",\"vue3-analysis_18-finish-complier-basic_18-finish-complier-basic.md\":\"474ec12d\",\"vue3-analysis_19-complier-basic-codegen_19-complier-basic-codegen.md\":\"5e6ad31d\",\"vue3-analysis_2-comp-init_2-comp-init.md\":\"e8851d91\",\"vue3-analysis_3-comp-update_3-comp-update.md\":\"effea2d2\",\"vue3-analysis_4-init-project_4-init-project.md\":\"a88a960b\",\"vue3-analysis_5-init-effect_5-init-effect.md\":\"12d5096f\",\"vue3-analysis_6-finish-readonly-isreactive_6-finish-readonly-isreactive.md\":\"8a15d2c1\",\"vue3-analysis_7-finish-ref-computed_7-finish-ref-computed.md\":\"684f5bff\",\"vue3-analysis_8-finish-build_8-finish-build.md\":\"8219d1c8\",\"vue3-analysis_9-init-comp-mount_9-init-comp-mount.md\":\"433a4a42\",\"vue3-analysis_index.md\":\"4ae721b1\",\"面试_1-前端面试准备_1-前端面试准备.md\":\"925efcba\",\"面试_10-offer收割机之浏览器原理篇_10-offer收割机之浏览器原理篇.md\":\"d0cb0668\",\"面试_11-offer收割机之手写代码篇_11-offer收割机之手写代码篇.md\":\"835e0e96\",\"面试_12-offer收割机之代码输出篇_12-offer收割机之代码输出篇.md\":\"c1445f4e\",\"面试_13-leetcode面试常考题目_13-leetcode面试常考题目.md\":\"868a095c\",\"面试_14-offer收割机之vue篇_14-offer收割机之vue篇.md\":\"6700c099\",\"面试_15-vue项目的性能优化_15-vue项目的性能优化.md\":\"3106bd1d\",\"面试_2-程序员面试软技能_2-程序员面试软技能.md\":\"52754b6f\",\"面试_3-offer收割机之html篇_3-offer收割机之html篇.md\":\"4ad7bfd4\",\"面试_4-offer收割机之css篇_4-offer收割机之css篇.md\":\"879e4504\",\"面试_5-offer收割机之javascript篇_5-offer收割机之javascript篇.md\":\"9970e901\",\"面试_6-offer收割机之性能优化篇_6-offer收割机之性能优化篇.md\":\"cc279da1\",\"面试_7-offer收割机之react篇_7-offer收割机之react篇.md\":\"eb6d1700\",\"面试_8-offer收割机之前端工程化篇_8-offer收割机之前端工程化篇.md\":\"c701d6a0\",\"面试_9-offer收割机之计算机网络篇_9-offer收割机之计算机网络篇.md\":\"ea61ff4a\"}")</script>
    <script type="module" async src="/common-study/assets/app.279bf150.js"></script>
    
  </body>
</html>